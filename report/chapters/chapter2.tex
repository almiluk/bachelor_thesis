\chapter{Анализ существующих решений задач, аналогичных поставленным}

\section{Анализ наиболее популярных средств управления энергонезависимой памятью}

\subsection{Требования к средству управления энергонезависимой памятью} \label{subsection:requirements}

Для программирования микроконтроллеров в проекте SciVi используются инструменты среды разработки Arduino IDE, позволяющие программировать микроконтроллеры, используя язык программирования C++, а также специальное дополнение к этой среде для работы с ESP8266 \cite{web:esp-core}, содержащее, в частности, набор "`стандартных"' библиотек.

соответственно, необходимое средство управления энергонезависимой памятью должно являться библиотекой языка C++ и может использовать стандартный набор библиотек Arduino IDE и указанного дополнения к ней.
Такая библиотека должна:
\begin{enumerate}
	\item Предоставлять пользователю возможность сохранять и считывать данные из EEPROM микроконтроллера. При этом:
	\begin{enumerate}
		\item Данные могут иметь произвольную структуру.
		\item Доступ к ним должен производиться по некоторым  идентификаторам, уникальным для различных данных и без необходимости ручных манипуляций с адресами EEPROM со стороны пользователя.
	\end{enumerate}
	\item Автоматически определять факт наличия в EEPROM данных с заданным идентификатором, определять адрес для записи новых данных, сохранять в EEPROM метаданные о хранящихся данных для их использования после перезапуска микроконтроллера.
	\item Минимизировать количество операций записи в EEPROM, т.к. каждая ячейка такой памяти может быть перезаписана ограниченное количество раз (обычно производители гарантируют от 100.000 до 1.000.000 циклов перезаписи), после чего выходит из строя.
	\item Выполняться на микроконтроллерах серии ESP8266 и, по возможности, на платформе Arduino, так как эта платформа является наиболее популярной и распространённой.
\end{enumerate}

Ключевым требованием является полная автоматизация работы с адресами EEPROM, это необходимо для создания возможности использования EEPROM в различных независимых программных модулях.
В противном случае, таким модулям понадобилось бы каким-либо образом обмениваться информацией об используемых ими адресах для избежания чтения и записи разными модулями в одни и те же ячейки EEPROM.


\subsection{Стандартная библиотека}

В стандартный набор библиотек Arduino IDE уже входит библиотека для работы с EEPROM \cite{web:arduino-eeprom}.
Как и SciVi в данный момент, большая часть проектов, хранящих какие-либо данные в EEPROM, ограничивается использованием этой библиотеки.
Однако она предоставляет только простые функции, такие как записать и считать байт по указанному адресу.
Позже в неё были добавлены функции для чтения и записи данных произвольных типов, но также только по явно указанному адресу.
Очевидно, это делает стандартную библиотеку нарушающей все поставленные требования, однако её функции можно использовать в качестве низкоуровневого интерфейса EEPROM в разрабатываемой библиотеке.
Кроме указанных, стандартная библиотека содержит функцию-обёртку вокруг функции записи, производящую фактическую перезапись данных только тогда, когда они отличаются от хранящихся по указанному адресу в данный момент.
В дальнейшем, в большинстве случаев, разумно использовать для записи именно эту функцию с целью уменьшения износа EEPROM.


\subsection{Библиотека EEPROMEx}

Библиотека EEPROMEx (от англ. Extended~--- Расширенный)~--- одна из первых разработок для работы с EEPROM микроконтроллеров в среде Arduiono IDE \cite{web:eepromex}.
Данная библиотека была создана раньше, чем описанная выше, поэтому часть предоставляемых ими возможностей совпадает, однако реализованы они независимо друг от друга.
EEPROMEx содержит функции для чтения и записи в EEPROM данных некоторых стандартных типов: целочисленных беззнаковых чисел длиной в 8, 16 и 32 бита и 32-х и 64-х битных чисел с плавающей точкой.
В библиотеке также содержатся функции для чтений и записи отдельных битов и, как и в стандартной библиотеке, аналогичные функции для работы с данными пользовательских типов и аналоги всех функций записи, производящие запись только при отличии данных.
Кроме того EEPROMEx содержит и уникальную возможность~--- с помощью класса EEPROMVar связывать одним объектом переменные в коде программы и данные в EEPROM (их адреса).
Причём эти адреса назначаются автоматически, что косвенно соответствует части требований, описанных в пункте \ref{subsection:requirements}.
Рассмотрим пример использования EEPROMVar, демонстрирующий большую часть возможностей данного класса:

\lstinputlisting[language=C++]{resources/code_listings/EEPROMex-var-example.cpp}

%\begin{lstlisting} %\begin{verbatim}

%\end{lstlisting}

Как можно увидеть в строке 1 примера, при создании объекта класса EEPROMVar указывается тип данных, которые необходимо хранить (в примере~--- float), и значение по умолчанию, которое передаётся в конструктор в виде параметра (в примере~--- 5.5).
Метод restore, вызываемый в строке 3, считывает из EEPROM данные, соответствующие данному объекту, и сохраняет в него эти данные .
В строке 5 демонстрируется возможность изменения хранимых данных с помощью оператора присвоения, причём в качестве левостороннего значения выступает объект класса EEPROMVar, а правостороннего~--- значение хранимого объектом типа пользовательских данных.
Это достигается за счёт переопределения оператора присвоения для данного класса.
В строке 7 показан обратный переход: объект класса EEPROMVar может быть переведёт в значение хранимого им типа.
В последней строке показан вызов метода save, сохраняющего значение, хранящееся в объекте, в EEPROM.

Также для класса EEPROMVar определены некоторые операторы, такие как оператор инкремента (++), присвоения со сложением (+=) и другие операторы, связанные с изменением хранимого значения.
Такие операторы вызывают в своём теле аналогичные для хранимых данных, что, разумеется, требует их существования.

Описанный класс механизм имеет ряд значительных недостатка.
Первый из них заключается в способе связывания данных и адреса, по которому они хранятся в EEPROM.
Обычно для этого данным выдаются уникальные имена, и каким-либо образом сохраняется информация о том, что данные с определённым именем находятся по определённому адресу.
Как можно увидеть в приведённом примере, при использовании библиотеки EEEPROMEx присвоения имён не происходит.
В этом случае данные располагаются в EEPROM друг за другом в порядке создания объектов класса EEPROMVar.
Таким образом, для того, чтобы гарантировать, что при перезапуске микроконтроллера объекты класса EEPROMVar связываются с одними и теме же адресами в EEPROM, необходимо обеспечивать создание этих объектов в строго одинаковом порядке при каждом включении устройства.
Эта работа ложится на плечи конечного пользователя~--- разработчика программы для микроконтроллера.
Причём даже в случае, если разработчик не применяет описываемый класс напрямую, но он используется в импортируемых итоговой программой библиотеках.

Второй проблемой является невозможность определения первого вызова конструктора для каких-либо пользовательских данных, то есть момента, в который эти данные отсутствуют в EEPROM, и необходимо записать значение по умолчанию.
И вновь разработчик конечной программы должен каким-либо образом самостоятельно определять, когда после создания объекта необходимо проводить сохранение в EEPROM значения по умолчанию, а когда наоборот считывание уже хранящегося в памяти значения.

В конечном итоге можно сделать вывод, что библиотека EEPROMEx частично соответствует предъявляемым требования, но при этом её использование нельзя назвать удобным, так как оно требует от конечного пользователя большой работы, которая могла бы быть автоматизирована.
При этом идея использовать переопределение операторов для получения и изменения пользовательских данных в EEPROM является крайне удачной и удобной в использовании.
Такой вариант предпочтительнее использования для тех же целей отдельных методов, так как, во-первых, позволяет пользователю библиотеки писать меньше кода и, во-вторых, позволяет ему думать об объекте, описывающем данные в EEPROM, как о самих этих данных.
В дальнейшем при разработке собственной библиотеки имеет смысл реализовать аналогичный интерфейс. % Убрать, чтоб не было вопросов про неиспользование этого в первой версии.


\subsection{Библиотека EEManager} \label{subsection:eemanager}

Сравнительно недавно была опубликована новая библиотека для работы с EEPROM~--- EEManager \cite{web:eemanager}.
Она имеет открытый исходный код (опубликован под лицензией MIT \cite{web:MIT}) и документацию на русском языке.
Так как данная библиотека значительно новее предыдущей рассмотренной, и в момент её создания уже существовала описанная выше версия стандартной библиотека, EEManager используют её возможности, в первую очередь~--- функции-обёртки, уменьшающие износ памяти.

Данная библиотека имеет следующие преимущества:
\begin{itemize}
	\item Реализован механизм отложенной записи: по умолчанию данные записываются в EEPROM с заданной задержкой после последней команды на запись. Использование такого подхода имеет смысл в ситуациях, когда данные должны перезаписываться много раз за короткий промежуток времени, в действительности же, с таким механизмом данные в EEPROM будут записаны только в последний раз, что значительно замедлит износ памяти. В то же время этот механизм имеет значительный недостаток: если потеря питания произойдёт после команды записи, но до истечения задержки, новые данные записаны не будут. Это делает использование такого механизма оправданным только в устройствах, для которых гарантия записи не является обязательной и точность восстановления состояния после потери питания не представляет критической важности.
	\item Библиотека также реализует "`механизм ключа первой записи"'. Вместе с каждым блоком данных в EEPROM хранится специальный однобайтовый ключ. При обращении к блоку данных пользователь указывает придуманный им ключ, который не должен изменяться от запуска к запуску, а из EEPROM считывается записанное значение ключа. Если они совпадают, значит необходимые данные уже находятся в EEPROM и их необходимо только считать, иначе данные никогда не были записаны, в этом случае данные должны быть сохранены в EEPROM.
\end{itemize}

Работа с библиотекой осуществляется следующим образом:
\begin{enumerate}
	\item Создаётся переменная в энергозависимой памяти, значение которой необходимо хранить в EEPROM.
	\item Создаётся специальный объект, описывающий блок данных EEPROM (некоторый аналог EEPROMVar из библиотеки EEEPROMEx).
	При этом пользователь указывает переменную в энергозависимой памяти, значение которой  необходимо хранить, и адрес в EEPROM, начиная с которого должна быть записана эта переменная.
	\item С помощью механизма ключа первой записи либо в EEPROM записывается значение переменной по умолчанию, либо наоборот сохранённое в EEPROM значение считывается в переменную.
	\item В дальнейшем, по необходимости, текущее значение переменной записывается в EEPROM.
	Для этого необходимо сначала обновить значение энергозависимой переменной, с которой связан описанный выше объект, а затем записать это новое значение в EEPROM.
	Чтобы сделать это, можно воспользоваться одним из двух методов: для немедленной записи и для запуска таймера записи с задержкой.
\end{enumerate}

Несмотря на указанные преимущества перед стандартной библиотекой, библиотека EEManager так же не может быть использована в готовом виде, так как обращение к блокам данных в ней производится только по их адресам.
Это делает невозможным независимое использование данной библиотеки из различных программных модулей.


\subsection{Библиотека EEPROMWearLevel}

В большинстве микроконтроллеров, в частности, на платформе Arduino, используется EEPROM с возможностью перезаписи отдельного байта, таким образом одни ячейки памяти могут изнашиваться быстрее других.
Для уменьшения скорости общего износа памяти имеет смысл как можно равномернее распределять количество циклов перезаписи по всем ячейкам EEPROM.
Классический способ такого распределения~--- использование кольцевого буфера \cite{web:circular-buffer}.

Идея этого метода заключается в перезаписи данных не по тому же адресу, а по новому, с некоторым сдвигом вперёд. Когда такой сдвиг становится невозможным из-за недостаточного объёма памяти, запись снова производится по первоначальному адресу.
При этом, чтобы иметь доступ к данным, необходимо постоянно хранить их текущий адрес или счётчик циклов перезаписи, и определять адрес по его значению.
В самом простом случае, если все данные хранятся в одном блоке, это можно сделать, умножив номер цикла на размер этого блока данных.
Однако, если хранить их по фиксированному адресу в EEPROM, соответствующие ячейки будут изнашиваться быстрее, что сделает использование кольцевого буфера бессмысленным.

Один из способов эффективной реализации счётчика~--- использование двух кольцевых буферов: одного для данных, второго~--- для счётчика.
Если при этом каждый раз при прохождении целого цикла записи (записи данных по изначальному адресу) для второго буфера, заполнять его нулевыми значениями, то после перезапуска микроконтроллера в этом буфере можно найти актуальное значение счётчика тривиальным образом~--- это будет последнее ненулевое значение в нём.

Другой способ основывается на использовании ещё одной особенности EEPROM микроконтроллеров: после стирания байта все его биты устанавливаются равными единице, и стандартная библиотека Arduino IDE предоставляет возможность устанавливать отдельным битам нулевое значение, без стирания всего байта.
За счёт этого можно хранить счётчик в своеобразной унарной системе счисления: десятичное значение счётчика равно количеству нулей в его побитовой записи.
Это позволит стирать ячейки EEPROM, хранящие счётчик, только при прохождении полного цикла записи в буфере данных.

Кольцевой буфер с последним из описанных механизмом эффективного счётчика реализует открытая библиотека EEPROMWearLevel \cite{web:eeprom-wear-level} (опубликована под лицензией Apache 2.0 \cite{web:apache-license-2.0}).
EEPROMWearLevel предоставляет интерфейс, аналогичный стандартной библиотеке, за исключением функции инициализации, в которую в данной библиотеке необходимо подать требуемое количество блоков EEPROM, дополняя этот интерфейс возможностью обращения к блокам данных по их индексам.
Указанное отличие в функциях инициализации вызвано тем, что данная библиотека создаёт отдельный кольцевой буфер для каждого блока данных, при этом весь объём EEPROM делится на буферы поровну между всеми хранящимися блоками данных.
Такое решение является неэффективным в случае хранения блоков разного размера.
В худшем случае размер одного или нескольких блоков может превышать размеры выделенного буфера, однако такой случай обрабатывается библиотекой и приведёт к выводу соответствующей ошибки и отмене записи такого блока.
Целостность других блоков при этим нарушена не будет.

Индексы блоков данных, используемые в этой библиотеке для доступа к ним, можно считать уникальными идентификаторами, описанными в требованиях, приведённых в начале главы.
Однако необходимость общей инициализации с указанием суммарного количества блоков данных делает невозможным применение данной библиотеки в независимых программных модулях.
Такой необходимости можно избежать, например, введя иерархическую структуру разделения EEPROM: сначала разделить весь объём EEPROM на крупные разделы (по одному или несколько на модуль), а затем внутри каждого из них~--- на кольцевые буферы, аналогично уже реализованному принципу.
Чтобы гарантировать, что потребности всех модулей в использовании EEPROM учтены, необходимо:
\begin{itemize}
	\item Либо проводить разделение EEPROM только после того, как все модули (посредством вызова некоторой специальной функции) сообщат библиотеке управления EEPROM их потребности в использовании EEPROM. Однако такой подход требует обязать конечного пользователя вызывать функцию инициализации библиотеки управления EEPROM строго после инициализации всех модулей, которым она необходима. А разработчиков этих модулей~--- вызывать функцию, описанную выше, при их инициализации. Такой подход, очевидно, является неудобным, так как требует от конечного пользователя знания о том, необходимо ли используемым им модулям хранить данные в EEPROM.
	\item Либо реализовать возможности динамического добавления новых разделов EEPROM, при этом уменьшая размер уже созданных разделов. Такой подход лишён недостатков первого, однако его использование значительно усложнит работу библиотеки из-за необходимости уменьшения размеров каждого кольцевого буфера при добавлении нового раздела и, возможно, сдвига данных, если эти данные в момент добавления выходят за уменьшенные границы буфера.
\end{itemize}

Можно заключить, что существует возможность дополнения данной библиотеки таким образом, чтобы она удовлетворяла всем поставленным требованиям.
В то же время данная библиотека не может напрямую использоваться с микроконтроллерами ESP8266, так как она содержит платформозависимый код, выполнение которого возможно только микроконтроллерами с архитектурой AVR, к которым ESP8266 не относится.
Кроме того, микроконтроллеры ESP8266 используют иной тип EEPROM~--- flash память \cite{web:esp-eeprom-src, web:usage-of-esp-eeprom}, которая не позволяет стирать и перезаписывать отдельные байты, а только их большие группы (обычно от 512 байт) \cite{incollection:flash-memory}.
Основное назначение этой памяти в данных микроконтроллерах~--- хранение исполняемых программ, однако её часть специально выделена для хранения пользовательских данных.
При этом в ходе анализа исходного кода стандартной библиотеки \cite{web:esp-eeprom-src} для работы с EEEPROM для ESP8266 было установлено, что для данных микроконтроллеров размер такой группы байт равен всему объёму flash-памяти, выделенному для пользовательских данных.

Таким образом, оказалось, что использование в программах для ESP8266 любых механизмов, подобных кольцевым буферам, не только не приводит к замедлению износа памяти, но и способно ускорять её износ из-за дополнительных операций перезаписи счётчиков и других метаданных.

\subsection{Вывод}

В ходе первого этапа работы были изучены особенности устройства и работы EEPROM.
Были составлены требования к программному модулю для работы с EEPROM микроконтроллеров.
С учётом этих требований были проанализированы существующие в открытом доступе решения.
На основе анализа было принято решение о разработке собственного модуля, а также об использовании в нём стандартной библиотеки для работы с EEPROM и целесообразности заимствования некоторых механизмов из других библиотек.


\section{Анализ широко используемых протоколов самоидентификации устройств Интернета вещей}

\subsection{Общее описание протоколов}

Протокол самоидентификации~--- сетевой протокол, позволяющий устройствам:
\begin{enumerate}
	\item Сообщать другим устройствам о своём присутствии в сети, сообщать свой локальный адрес.
	\item Предоставлять в некотором виде описание своей структуры и возможностей.
	\item Отвечать на поисковые запросы от других устройств в сети, если это устройство удовлетворяет определённым условиям (на имя, тип, состав и т.д.).
\end{enumerate}

Кроме того, важным требованием является отсутствие необходимости конфигурации, т.е., войдя в какую-либо сеть, устройство сразу должно получить все возможности, описанные выше без дополнительной его настройки или настройки других устройств в сети.

На первом этапе данной работы были рассмотрены следующие существующие прикладные протоколы самоидентификации, удовлетворяющие указанным требованиям:
\begin{enumerate}
	\item NetBIOS (Network Basic Input/Output System)
	\item DNS-SD (DNS Service Discovery)
	\item mDNS (multicast DNS)
	\item SSDP (Simple Service Discovery Protocol)
	\item SLP (Service Location Protocol)
\end{enumerate}

Все рассматриваемые протоколы используют один и тот же транспортный протокол~--- UDP и одинаковый механизм поиска устройств, этот механизм продемонстрирован на рисунке \ref{fig:search-alg}.
Основой данного механизма является отправка пакетов (датаграмм) на специальные мультивещательные (англ. Multicast) адреса, т.е. всем устройствам, заявившим о своём вхождении в специальную широковещательную группу (на рисунке \ref{fig:search-alg} передача таких пакетов обозначена пунктирными стрелками, а устройства, входящие в мультивещательную группу жёлтыми кругами, остальные устройства~--- чёрными).
Новое устройство, входя в сеть и вступая в мультевещательную группу, отправляет устройствам в этой группе информацию о своём появлении в сети и своё описание, в форматах, зависящих от конкретного протокола (Рисунок \ref{fig:search-alg}.б).
Далее, если какому-либо устройству в группе необходимо найти (т.е. узнать его адрес) другого устройства, оно отправляет на мультивещательный адрес пакет, содержащий описание искомого устройства (Рисунок \ref{fig:search-alg}.в).
Затем, те устройства, которые считают, что они удовлетворяют полученному описанию (на рисунке такие устройства обозначены зелёными кругами), отправляют ответ, содержащий адрес этого устройства и, возможно, его описание (Рисунок \ref{fig:search-alg}.г), причём делают это не с помощью мультивещательной передачи данных, а напрямую по обратному адресу, указанному в поисковом пакете.

\myfigure[width=0.7\columnwidth]{search-alg}{Основной алгоритм поиска устройств}{fig:search-alg}

Различаются же эти протоколы между собой наборами используемых для передачи данных сетевых протоколов, возможностями для составления поисковых запросов и наборами дополнительных функций.

\subsection{Протокол NetBIOS}
Данный протокол был разработан в 1983 году и, в данный момент, реализующие его приложения по умолчанию входят во все операционные системы Windows и macOS, а также в некоторые системы семейства Linux.
Стандарт NetBIOS описывает три службы, которые должны выполняться на устройствах: служба имён (NetBIOS-NS), служба сеанса (NetBIOS-SSN) и служба рассылки датаграмм (NetBIOS-DGM).
Первая из них обеспечивает выделение имени для устройства, по которому его смогут найти другие устройства, а также разрешение конфликтов имён.
Служба сеансов позволяет по имени устройства установить с ним сеанс связи и обмениваться данными по TCP.
А служба датаграмм позволяет отправить UDP пакет устройству с конкретным именем или всем устройствам в сети \cite{web:netbios}.

\subsection{Протоколы DNS-DS и mDNS}
Эти протоколы чаще всего встречаются вместе, т.к. оба входят в набор технологий для сетей нулевой конфигурации Zeroconf, разработанный компанией Apple.
Они имеют реализации для всех популярных операционных систем.
Хотя в названии этих протоколов есть "`DNS"' (англ. Domain Name System~--- система доменных имён), они не требуют наличия отдельных DNS-серверов и существования таблиц доменных имён, однако допускают их использование для уменьшения числа поисковых запросов в сети.
Оба этих протокола передают данные в виде стандартных DNS-пакетов.
При этом, mDNS, в качестве искомого имени, передаёт имя устройства в специальном домене первого уровня .local.
Очевидно, что имена в одной сети не должны повторяться, а также они должны быть заранее известны как устройствам, осуществляющим поиск, так и самим искомым устройствам \cite{web:dns-ds,web:mdns}.
А DNS-DS, вместо имён устройств, использует специальные доменные имена, обозначающие различные сервисы, которые должны предоставлять искомые устройства (например, {\_}printer.{\_}tcp.local для сервиса печати или {\_}raop.{\_}tcp.local для AirTunes и т.д.) \cite{web:dns-ds, book:zero-conf-guide}.
Предполагается, что такие имена сервисов берутся из специального реестра имён организации IANA \cite{web:iana-dns-ds}.

\subsection{Simple Service Discovery Protocol}
Протокол SSDP (от Simple Service Discovery Protocol) является частью протокола UPnP (англ. Universal Plug and Play), разработанного форумом UPnP и в данный момент поддерживаемого организацией Open Connectivity Foundation.
UPnP также реализован для большинства операционных систем, а в некоторые даже встроен.
Протокол SSDP позволяет искать устройства по специальным уникальным идентификаторам, типам устройств, а также идентификаторам и типам сервисов, предоставляемых устройствами.
Типы устройств и сервисов разделены на домены, каждый производитель устройств в праве задавать свой домен и имена в нём.

По протоколу SSDP данные передаются в текстовом виде в формате запросов HTTP, но без тела запроса.
Т.е. каждый передаваемый пакет состоит из заголовка, описывающего этот пакет, и набора пар имя-значение (заголовков HTTP).
Документация протокола описывает обязательные заголовки, которые должны содержаться в пакете, оставляя возможность добавлять любые другие, если только их имена уникальны внутри одного пакета \cite{web:upnp}.

\subsection{Service Location Protocol}
Данный протокол присваивает каждому устройству одну или несколько из следующих ролей: user agent~--- устройство, которое ищет сервис, service agent~--- устройство, предоставляющее какие-либо сервисы, и directory agent, кэширующий информацию о сервисах и устройствах, их предоставляющих.
Устройства последнего типа могут отсутствовать в сети, однако, если они есть, для поиска сервисов обязаны использоваться они, а не прямой поиск.

Важной отличительной чертой данного протокола является возможность задавать сервисам не только имена, но и произвольные атрибуты, которые могут изменяться со временем.
Для формирования пакетов данных Service Location Protocol (SLP) использует свой собственный бинарный протокол, позволяющий эффективно кодировать и передавать информацию о сервисах и устройствах.
С помощью SLP возможно проводить поиск сервисов по именам, типам, областям (англ. Scopes), а также предикатам в формате LDAP Search Filters, зависящим от значений атрибутов сервиса.

Помимо этого, SLP включает в себя механизмы защиты подлинности пакетов на основе открытых ключей.
В данный момент протокол не имеет особой популярности, так, в частности, компания Apple, продвигавшая его ранее, перешла в своих продуктах на стек Zeroconf \cite{web:slp}.

\subsection{Сравнение протоколов самоидентификации}

На основании анализа протоколов была построена сравнительная таблица (Таблица \ref{tab:selfid-prots-comparing}).

\begin{center}
	\begin{longtable}{|p{0.3\columnwidth}|c|c|c|c|c|}
		\caption{ \raggedright Сравнение протоколов самоидентификации }
		\label{tab:selfid-prots-comparing}
		\\ \hline
		Критерий & NetBIOS & DNS-SD & mDNS & SSDP & SLP \\
		\hline \endfirsthead
		\subcaption{\raggedright Продолжение таблицы~\ref{tab:selfid-prots-comparing}}
		\\ \hline \endhead
		\hline \subcaption{Продолжение на след. стр.}
		\endfoot
		\hline \endlastfoot
		Возможность передачи дополнительной информации &  $+$  & $-$ & $-$ & $+$ & $-$ \\
		\hline
		Возможность поиска по именам & $+$ & $+$ & $+$ & $+$ & $+$ \\
		\hline
		Возможность поиска по типам  & $-$ & $+$ & $-$ & $+$ & $+$ \\
		\hline
		Возможность поиска с помощью предикатов & $-$ & $-$ & $-$ & $-$ & $+$ \\
		\hline
		Возможность поиска не только устройств, но и сервисов & $-$ & $+$ & $-$ & $+$ & $+$ \\
		\hline
		Наличие дополнительных механизмов защиты & $-$ & $-$ & $-$ & $-$ & $+$ \\
		\hline
		Наличие механизмов уведомления о вхождении устройства в сеть & $+$ & $-$ & $-$ & $+$ & $+$ \\
		\hline
		Бинарный протокол представления данных & $-$ & $+$ & $+$ & $-$ & $+$ \\
		\hline
		Год появления актуальной редакции протокола & 1987 & 2013 & 2013 & 2015 & 1999 \\
	\end{longtable}
\end{center}

Помимо критериев, приведённых в таблице, при выборе протокола для реализации учитывалось количество особенностей протокола, которые не являются необходимыми для достижения цели данной работы, но которые необходимо реализовать для соответствия протоколу.
С учётом отсутствия других явных преимуществ, это исключает из выбора NetBIOS, т.к., для возможности обмена данными помимо простого поиска, он требует реализации массы дополнительных функций, связанных, в частности, с поддержкой механизма сеансов.

Протоколы SLP, DNS-SD и mDNS не обеспечивают возможность передачи дополнительной информации, не выходя за рамки протокола, в соответствии с поставленной целью работы, возможность использования протокола для взаимодействия с помощью онтологий является критичной.
Поэтому становится необходимым, в случае выбора одного из этих протоколов, разработать некоторый дополнительный механизм поверх него для такого взаимодействия.
Очевидно, в случае SLP и DNS-SD, это не имеет особого смысла, т.к.
по другим критериям они также проигрывают оставшимся конкурентам.

Каждый из оставшихся протоколов SLP и SSDP обладает и значительными преимуществами, и недостатками.
Однако, преимущества протокола SLP являются менее значимыми, потому что:
\begin{itemize}
	\item Возможность использовать для поиска сервисов предикаты и, соответственно, возможность задавать сервисам произвольные атрибуты являются достаточно сложными в реализации и не менее сложными в интеграции в платформу SciVi.
	При этом, функциональность, связанную с атрибутами и проверкой их значений, можно переложить на аппарат онтологий и механизмы их обработки.
	\item Вопросы безопасности на данном этапе не входят в рассмотрение и остаются за рамками исследования.
	\item Экономией объёма передающихся данных также можно пренебречь, т.к. обмен данными по протоколу самоидентификации осуществляется только в моменты поиска устройств, т.е. достаточно редко.
\end{itemize}

Таким образом, недостатки протокола SSDP являются незначительными или устранимыми на уровне обработки онтологий, а его преимущества идеально ложатся на рассматриваемую предметную область.

\subsection {Вывод}

В результате сравнения можно сделать вывод, что протокол SSDP~--- единственный из рассмотренных, который позволяет, полностью оставаясь в рамках одного протокола, удобно для использования совместить в одном решении поиск устройств и передачу онтологий для дальнейшей обработки.
Следовательно, для последующей реализации следует выбрать именно его.
