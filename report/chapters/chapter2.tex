\chapter{Разработка библиотеки менеджера EEPROM}

\section{Первая версия библиотеки}

После анализа существующих решений, была разработана собственная библиотека.
Её исходный код находится в открытом доступе в специальном репозитории, вместе с примерами использования и тестирующими библиотеку программами для микроконтроллеров \cite{web:my-eemanager}.
Разработанная библиотека основывалась только на библиотеке EEManager, которая на тот момент казалась наиболее удачной из рассмотренных библиотек.
Однако после реализации и тестирования было установлено, что логика созданной библиотеки работает в соответствии с поставленными требованиями, но её интерфейс проявил является крайне неудобным и недостаточно высокоуровневым.
Общий вид этого интерфейса был продиктован идеей сохранить частичную обратную совместимость с библиотекой EEManager и переиспользовать её код, что привело к предоставлению пользователю недостаточно высокоуровневых функций.

% TODO: ОПИСАТЬ ЧУТЬ ПОДРОБНЕЕ.
% TODO: ДОБАВИТЬ ДИАГРАММУ КЛАССОВ ВНЕШНЕГО ИНТЕРФЕЙСА БИБЛИОТЕКИ.
% TODO: Добавить определение EEPROM раздела и EEPROM переменной.

\section{Уточнение требований к разрабатываемой библиотеке}

После признания первой версии библиотеки неудачной, было принято решение о разработке второй со следующими изменениями:

\begin{enumerate}
	\item Объединить одной сущностью данные в оперативной памяти и объекты, описывающие связанные с ними данные в EEPROM.
	При использовании такой сущности первоначальное считывание значения из EEPROM (или запись в него значения по умолчанию) возможно производить в конструкторе класса, соответствующего такой сущности.
	Дальнейшее же получение из неё пользовательских данных и их обновление в EEPROM реализовать за счёт переопределения операторов, аналогично классу EEPROMVar из библиотеки EEPROMEx.
	Это позволить одновременно (с точки зрения пользователя) работать и с данными в оперативной памяти, и с их представлением в EEPROM.
	% \item Заменить явное использование разделов неявным и позволить пользователю использовать большую глубину вложенности пространств имён.
	\item Реализовать механизм отложенной записи для всего EEPROM в целом, а не для каждой EEPROM-переменной по отдельности.
	\item Завязать такой механизм на количестве обращений на запись, а не на реальном времени, как в EEManager.
	\item Реализовать возможность немедленного обновления данных в EEPROM в случае необходимости.
\end{enumerate}

На основе дополненного списка требований к библиотеке можно составить диаграмму прецедентов работы с ней. Она представлена на рисунке \ref{fig:ucd}.

\myfigure[width=\columnwidth]{UCD}{Диаграммы прецедентов использования библиотеки}{fig:ucd}

На диаграмме отсутствует прецедент удаления переменной в связи с тем, что, как писалось выше, основная цель применения EEPROM в программах для  микроконтроллеров~--- сохранение состояния устройства между его запусками.
Как правило, для запуска микроконтроллера с одной и той же программой необходимы одни и те же данные, следовательно, удалять их нет необходимости.

\section{Разработка структуры библиотеки}

\subsection{Общая структура библиотеки} \label{subsection:library-structure}

В соответствии с общепринятым стилем, библиотека должна быть написана с использованием объектно-ориентированной парадигмы программирования.
Основное, которыми оперирует разрабатываемая библиотека~--- EEPROM-переменная, следовательно, в библиотеке должен содержаться класс, соответствующий этому понятию.
Кроме того, необходим отдельный класс, оперирующий EEPROM в целом. Назовём его классом менеджера памяти.
К этому классу должны обращаться EEPROM-переменные для их поиска или добавления в память и обновления их значений.

Важно учитывать, что стандартные библиотеки EEPROM для различных микроконтроллеров обычно работают схожим образом, но всё же могут иметь отличая.
В частности незначительно отличаются такие библиотеки и для целевых платформ данной работы~--- Arduino и ESP8266.
В следствии этого необходимо вынести все операции, использующие функции этих библиотек в отдельную сущность с тем, чтобы была возможность легко её изменить для использования других микроконтроллеров.
Удобнее всего это сделать, определив абстрактный класс, предоставляющий унифицированные методы-обёртки над стандартными функциями, и создав конкретные реализации такого класса для различных микроконтроллеров.
Этот же класс должен реализовывать механизмы уменьшения износа памяти, так как они могут быть различными для различных микроконтроллеров.
Такой подход также позволит легче адаптировать разрабатываемую библиотеку для использования с абсолютно другими микроконтроллерами.

Для хранения EEPROM-переменных было решено использовать механизм, схожий с механизмами, используемыми в файловых системах.
В описание каждой переменной включается адрес следующей, либо специальное значение, обозначающее, что данная переменная является последней в разделе.
Адрес первой же переменной является константой и не изменяется при перезапуске устройства.

Также в энергонезависимой памяти стоит хранить специальное проверочное значение, показывающее, был ли менеджер инициализирован в EEPROM, и, в случае, если не был, инициализировать его.
Причём имеет смысл объявить два таких значения, оба из которых свидетельствуют о том, что менеджер инициализирован, но одно из них используется в случае, если в EEPROM была объявлена хотя бы одна переменная, в противном случае, используется второе значение.
Использование такого механизма необходимо для избежания чтения "`мусорных"' данных, находящихся в EEPROM до первого использования менеджера.
Также изменение этого значения в последующих версиях библиотеки можно использовать для принудительной переинициализации менеджера в случае изменения структуры хранения данных при выходе новой версии.

Принудительная переинициализация менеджера также требуется и при перепрошивке микроконтроллера в противном случае в энергонезависимой памяти будут накапливаться неиспользуемые переменные от предыдущих программ, загруженных в устройство.
Arduino IDE автоматически создаёт константы, описывающие время компиляции программы и доступные из её кода.
Это время можно также сохранять в EEPROM и при запуске микроконтроллера проверять, совпадает ли время компиляции текущей программы с сохранённым временем.
Если они отличны, переинициализацировать менеджер, считая, что больше в EEPROM нет сохранённых переменных.
Для хранения времени компиляции оптимально использовать формат Unix time~--- количество секунд, прошедших с момента времени 00:00:00 1 января 1970 года, обычно хранящееся в виде 4-х байтного знакового целого числа.
Такой формат является наилучшим, так как позволяет хранить время используя небольшой объём памяти, что является критичным, с учётом ограниченности объёмов EEPROM.

Логическая схема размещения данных в EEPROM показана на рисунке \ref{fig:logical-eeprom-data-structure}.

Для идентификации EEPROM-переменных было решено использовать произвольные строковые выражения~--- имена.

\mysvg[inkscapelatex=false,width=\columnwidth]{logical-eeprom-data-structure}{логическая схема размещения данных в EEPROM}{fig:logical-eeprom-data-structure}


\subsection{Внешний интерфейс библиотеки}

Пользователю для использования должен быть доступен всего один класс EEPROMVar, описывающий EEPROM-переменную, его структура показана на рисунке \ref{fig:inerface-class-diagram}.
Данный класс является шаблонным, и его параметр типа определяет тип хранящихся пользовательских данных.

Этот класс имеет следующие методы
\begin{enumerate}
	\item Конструктор. Он принимает в качестве аргументов имя переменной и её значение по умолчание.
	Если переменная с таким именем уже существует, её значение считывается из энергонезависимой памяти и сохраняется в создаваемый объект, иначе в EEPROM создаётся новая переменная и в неё записывается значение по умолчанию.
	\item Update~--- запланировать запись нового значения в EEPROM.
	Метод имеет две перегрузки: не принимающую аргументов~--- для записи текущего значения пользовательских данных, и принимающая новое значение для этих данных, которая планирует запись этого нового значения.
	\item UpdateNow~--- метод для немедленного обновления значения в EEPROM.
	Так же имеет две перегрузки аналогично предыдущему методу.
	\item Data~--- метод, возвращающий по ссылке пользовательские данные, хранящиеся объектом.
	\item Оператор присвоения ("`="').
	Работает аналогично методу Update, принимая новое значение пользовательских данных в качестве правостороннего значения.
	В отличие от аналогичного оператора класса EEPROMVar библиотеки EEPROMEx, данный сам производит (отложенную) запись новых данных, без необходимости отдельного вызова метода записи.
	\item Оператор приведения объекта к типу хранящихся в нём пользовательских данных.
	Возвращает текущее значение хранимы данных, причём делает это по ссылке, как и метод Data.
\end{enumerate}

В виде полей данный класс хранит сами пользовательские данные и адрес в EEPROM для их обновления.

Можно привески следующий пример использования класса EEPROMVar:

\lstinputlisting[language=C++]{resources/code_listings/EEPROManager-var-example.cpp}

ОБЪЯСНЕНИЕ ПРИМЕРА ИСПОЛЬЗОВАНИЯ


\iffalse
\subsection{EEPROM-переменные}

Помимо указателя на данные в оперативной памяти, которые необходимо сохранять, описание переменной должно включать значение задержки отложенной записи и мета-данные о записи переменной в EEPROM.
Эти данные приведены в таблице \ref{tab:eeprom-var}.

\begin{center}
	\begin{longtable}{|p{0.2\columnwidth}|c|p{0.5\columnwidth}|}
		\caption{ \raggedright Мета-данные EEPROM-переменной}
		\label{tab:eeprom-var}
		\\ \hline
		Размер & Название поля & Описание \\
		\hline \endfirsthead
		\subcaption{\raggedright Продолжение таблицы~\ref{tab:eeprom-var}}
		\\ \hline \endhead
		\hline \subcaption{Продолжение на след. стр.}
		\endfoot
		\hline \endlastfoot
		4 байта & nameHash & Хэш-значение имени переменной. Используется для фиксации объёма памяти, занимаемого именем. Используется хэш-функция CRC32 \cite{article:crc-32}. \\
		\hline
		2 байта & dataSize & Размер данных, хранящихся в переменной. \\
		\hline
		2 байта & nextVarAddr & Адрес следующей переменной в этом же разделе. \\
		\hline
		2 байта & addr & Адрес в EEPROM, по которому хранится переменная. \\
	\end{longtable}
\end{center}

Все указанные выше поля переменной, кроме адреса, необходимо хранить в EEPROM, адрес же можно узнать в процессе поиска переменной и хранить только в оперативной памяти.
Для удобства записи и чтения мета-данных, те из них, которые необходимо хранить в EEPROM, следует вынести в отдельную структура~--- VariableInfo.

\subsection{Разделы памяти}

Для удобства чтения и записи информации о разделе в EEPROM, все данные о разделе, которые необходимо сохранять между запусками, было решено вынести в отдельный класс~--- MemPartInfo, а класс MemPart унаследовать от него.
В данной версии библиотеки к таким данным относится только адрес первой переменной раздела.

\subsection{Менеджер памяти}

Классу менеджера EEPROM необходимы следующие поля:
\begin{enumerate}
	\item lastAddr~--- последний использованный адрес.
	\item lastAddrVar~--- объект EEPROM-переменной для обновления последнего использованного адреса.
	\item metaMemPart~--- объект, описывающий указанный в подпункте \ref{subsection:library-structure} системный раздел памяти.
	\item startAddr~--- стартовый адрес в EEPROM, используемый менеджером.
	По умолчанию равен нулю, то есть используется весь доступный объём EEPROM.
\end{enumerate}

В энергонезависимой памяти из этих значений необходимо хранить только последний использованный адрес: стартовый адрес и адрес, по которому хранится описание системного раздела, фиксируется в момент компиляции.

\section{Разработка библиотеки}

Итоговая диаграмма классов разрабатываемой библиотеки представлена ниже на рисунке \ref{fig:class-diagram}.


\myfigure[width=\columnwidth]{class-diagram}{Диграмма классов библиотеки}{fig:class-diagram}

Библиотека была реализована в соответствии с представленной диаграммой.
В данном отчёте не приводятся детали реализации отдельных методов, однако исходный код разработанной библиотеки находится в открытом доступе в специальном репозитории, вместе с примерами использования и тестирующими библиотеку программами для микроконтроллеров \cite{web:my-eemanager}.
Код содержит комментарии, необходимые для генерации документации средствами Doxygen \cite{web:doxygen}.

Работа библиотеки была протестирована на микроконтроллерах серии ESP8266 и платформы Arduino.
Проведённое тестирование показало, что логика библиотеки работает в соответствии с поставленными требованиями.
Однако, её интерфейс проявил себя крайне неудобным и недостаточно высокоуровневым.
Общий вид этого интерфейса был продиктован идеей сохранить частичную обратную совместимость с библиотекой EEManager и переиспользовать её код, что привело к предоставлению пользователю слишком низкоуровневых функций для работы с EEPROM-переменными.
В то же время более высокоуровневые функции реализованы не были.

В дальнейшем необходимо, используя часть реализованных низкоуровневых функции, разработать обновлённую версию библиотеки, предоставляющую пользователю интерфейс более высокого уровня и не завязанную на использование библиотеки EEManager.
В обновлённой версии необходимо:
\begin{enumerate}
	\item Объединить в цельную сущность переменные в оперативной памяти и объекты, описывающие связанные с ними EEPROM-переменные.
	При использовании такой сущности первоначальное считывание значения из EEPROM (или запись в него значения по умолчанию) возможно производить в конструкторе класса, соответствующего такой сущности.
	Дальнейшее же получение из неё пользовательских данных и их обновление в EEPROM реализовать за счёт переопределения операторов.
	Это позволить одновременно (с точки зрения пользователя) работать и с данными в оперативной памяти, и с их представлением в EEPROM.
	\item Заменить явное использование разделов неявным и позволить пользователю использовать большую глубину вложенности пространств имён.
	\item Реализовать механизм отложенной записи для всего EEPROM в целом, а не для каждой EEPROM-переменной по отдельности.
	\item Реализовать возможность немедленного обновления данных в EEPROM в случае необходимости.
\end{enumerate}

\fi
