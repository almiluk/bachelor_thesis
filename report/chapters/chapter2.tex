\chapter{Разработка библиотеки менеджера EEPROM}

\section{Уточнение требований к разрабатываемой библиотеке}

На основе требования об обеспечении независимости работы с EEPROM из различных программных модулей и с целью уменьшения количества коллизий пользовательских идентификаторов данных, было принято решение реализовать следующее:
\begin{enumerate}
	\item Ввести иерархию идентификаторов блоков данных: не хранить все идентификаторы в едином пространстве имён, а создавать множество таких пространств и реализовать механизм обращения к ним по особым идентификаторам, которые должны быть уникальны между собой.
	\item Обязать разработчиков программных модулей, использующих разрабатываемую библиотеку, создавать для этих модулей отдельные пространства имён EEPROM, идентификаторы которых должны быть связаны с названием модуля, а непосредственно используемые блоки данных описывать внутри этих пространств имён.
	\item Обязать разработчиков самостоятельно поддерживать уникальность идентификаторов внутри отдельных модулей.
\end{enumerate}

Такой шаг позволит изолировать друг от друга идентификаторы, используемые различными разработчиками в различных программных модулях.
Важно отметить, что вероятность коллизий идентификаторов самих пространств имён является небольшой, с учётом привязки этих идентификаторов к названиям модулей, в которых они создаются.
Таким образом, разработчики смогут применять данную библиотеку, не задумываясь о других программных модулях, использующих её, что выполняет основное требование к разрабатываемой библиотеке.
В дальнейшем будем называть такие пространства имён разделами, а пользовательские блоки данных, хранящиеся в EEPROM -- EEPROM-переменными.

На основе дополненного списка требований к библиотеке можно составить диаграмму прецедентов работы с ней. Она представлена на рисунке \ref{fig:ucd}.

\myfigure[width=\columnwidth]{UCD}{Диаграммы прецедентов использования библиотеки}{fig:ucd}

На диаграмме отсутствует прецедент удаления переменной в связи с тем, что, как писалось выше, основная цель применения EEPROM в программах для  микроконтроллеров -- сохранение состояния устройства между его запусками.
Как правило, для запуска микроконтроллера с одной и той же программой необходимы одни и те же данные, следовательно, удалять их нет необходимости.

\section{Разработка структуры библиотеки}

\subsection{Общая структура библиотеки} \label{subsection:library-structure}

В соответствии с общепринятым стилем, библиотека должна быть написана с использованием объектно-ориентированной парадигмы программирования.
Основные понятия, которыми оперирует разрабатываемая библиотека -- раздел и EEPROM-переменная, следовательно, в библиотеке должны содержаться классы, соответствующие этим понятиям.
Кроме того, необходим отдельный класс, оперирующий EEPROM в целом. Назовём его классом менеджера памяти.

Для хранения EEPROM-переменных внутри разделов было решено использовать механизм, схожий с механизмами, используемыми в файловых системах.
В описание раздела входит адрес первой EEPROM-переменной этого раздела, а в описание каждой переменной -- адрес следующей в этом же разделе, либо специальное значение, если переменная является последней в разделе.
Информация о каждом разделе сохраняется в EEPROM за счёт создания отдельной EEPROM-переменной, связанной с объектом, описывающим этот раздел.
Для хранения таких переменных создаётся специальный системный раздел, который находится всегда по одному и тому же адресу в EEPROM и хранит в себе все EEPROM-переменные, связанные с другими разделами.
Кроме того, в системном разделе можно хранить последний использованный адрес для создания возможности добавлять новые разделы и переменные после перезапуска устройства.

Также в энергонезависимой  вать его.
Это необходимо для избежания чтения "`мусорных"' данных, находящихся в EEPROM до первого использования менеджера.
Также изменение этого значения в последующих версиях библиотеки можно использовать для принудительной переинициализации менеджера в случае изменения структуры хранения данных при выходе новой версии.
Логическая схема размещения данных в EEPROM показана на рисунке \ref{fig:logical-eeprom-data-structure}.

Для идентификации разделов и EEPROM-переменных было решено использовать произвольные строковые выражения -- имена.

\mysvg[inkscapelatex=false,width=\columnwidth]{logical-eeprom-data-structure}{логическая схема размещения данных в EEPROM}{fig:logical-eeprom-data-structure}


\subsection{Внешний интерфейс библиотеки}

С точки зрения пользователя библиотеки, её классы должны выглядеть как показано на рисунке \ref{fig:inerface-class-diagram}.
На данном рисунке EEPROMVar -- класс, описывающий EEPROM-переменную.
Его публичные методы взяты из соответствующего класса библиотеки EEManager (пункт \ref{section:eemanager}).
Описание методов:
\begin{enumerate}
	\item updateNow -- мгновенная запись нового значения в EEPROM.
	\item update -- запланировать запись нового значения, то есть запустить таймер отложенной записи.
	\item tick -- метод, который необходимо вызывать регулярно, если используется отложенная запись: реальная запись нового значения EEPROM произойдёт при первом вызове метода tick() после истечения задержки записи.
	\item getTimeout -- вернуть текущее значение задержки записи.
	\item setTimeout -- установить новое значение задержки записи.
\end{enumerate}

Класс MemPart описывает раздел EEPROM. 
Его метод getVar должен возвращать EEPROM-переменную с именем, равным значению параметра name, и связывать её с локальной переменной произвольного типа T, хранящейся в оперативной памяти устройства, указателем на которую является параметр data.
В случае, если EEPROM-переменная с указанным названием уже содержится в данном разделе, её значение должно копироваться в локальную переменную по тому же адресу, преобразуясь в значение типа T.
Иначе, должна создаваться новая EEPROM-переменная, а значение локальной переменной записываться в неё.
При этом важно учитывать, что, так как локальная переменная связывается с EEPROM-переменной, область видимости связываемой локальной переменной должна быть не уже области видимости объекта класса EEPROMVar, полученного вызовом метода getVar.

Класс EEMemManager описывает менеджер памяти и имеет два статических метода:
\begin{enumerate}
	\item init -- метод для инициализации менеджера.
	\item getMemPart -- метод, аналогичный методу getVar класса MemPart, но работающий с разделами, а не с переменными.
\end{enumerate}

\mysvg[inkscapelatex=false,width=\columnwidth]{interface-cd}{Диаграмма классов библиотеки с точки зрения её пользователя}{fig:inerface-class-diagram}

Итоговый алгоритм взаимодействия пользователя с библиотекой должен выглядеть следующим образом:
\begin{enumerate}
	\item Вызов метода EEMemManager.init при инициализации программного модуля, использующего менеджер EEPROM.
	\item Получение/создание раздела памяти вызовом метода EEMemManager.getMemPart с именем раздела, связанным с названием модуля.
	\item Создание переменных в оперативной памяти, значение которых необходимо сохранять в EEPROM.
	\item Получение/создание необходимых EEPROM-переменных и их связывание с переменными в оперативной памяти с помощью метода getVar полученного раздела.
	\item Вызов методов обновления значений EEPROM-переменных (updateNow или update и tick) по необходимости.
	\item Предполагается, что для передачи синхронизируемых через EEPROM данных между частями программного модуля будут использоваться переменные из оперативной памяти. Однако при необходимости, повторным вызовом метода MemPart.getVar возможно считать актуальное значение EEPROM-переменной.
\end{enumerate}


\subsection{EEPROM-переменные}

Помимо указателя на данные в оперативной памяти, которые необходимо сохранять, описание переменной должно включать значение задержки отложенной записи и мета-данные о записи переменной в EEPROM.
Эти данные приведены в таблице \ref{tab:eeprom-var}.

\begin{center}
	\begin{longtable}{|p{0.2\columnwidth}|c|p{0.5\columnwidth}|}
		\caption{ \raggedright Мета-данные EEPROM-переменной}
		\label{tab:eeprom-var}
		\\ \hline
		Размер & Название поля & Описание \\
		\hline \endfirsthead
		\subcaption{\raggedright Продолжение таблицы~\ref{tab:eeprom-var}}
		\\ \hline \endhead
		\hline \subcaption{Продолжение на след. стр.}
		\endfoot
		\hline \endlastfoot
		4 байта & nameHash & Хэш-значение имени переменной. Используется для фиксации объёма памяти, занимаемого именем. Используется хэш-функция CRC32 \cite{article:crc-32}. \\
		\hline
		2 байта & dataSize & Размер данных, хранящихся в переменной. \\
		\hline
		2 байта & nextVarAddr & Адрес следующей переменной в этом же разделе. \\
		\hline
		2 байта & addr & Адрес в EEPROM, по которому хранится переменная. \\
	\end{longtable}
\end{center}

Все указанные выше поля переменной, кроме адреса, необходимо хранить в EEPROM, адрес же можно узнать в процессе поиска переменной и хранить только в оперативной памяти.
Для удобства записи и чтения мета-данных, те из них, которые необходимо хранить в EEPROM, следует вынести в отдельную структура -- VariableInfo.

\subsection{Разделы памяти}

Для удобства чтения и записи информации о разделе в EEPROM, все данные о разделе, которые необходимо сохранять между запусками, было решено вынести в отдельный класс -- MemPartInfo, а класс MemPart унаследовать от него.
В данной версии библиотеки к таким данным относится только адрес первой переменной раздела.

\subsection{Менеджер памяти}

Классу менеджера EEPROM необходимы следующие поля:
\begin{enumerate}
	\item lastAddr -- последний использованный адрес.
	\item lastAddrVar -- объект EEPROM-переменной для обновления последнего использованного адреса.
	\item metaMemPart -- объект, описывающий указанный в подпункте \ref{subsection:library-structure} системный раздел памяти.
	\item startAddr -- стартовый адрес в EEPROM, используемый менеджером.
	По умолчанию равен нулю, то есть используется весь доступный объём EEPROM.
\end{enumerate}

В энергонезависимой памяти из этих значений необходимо хранить только последний использованный адрес: стартовый адрес и адрес, по которому хранится описание системного раздела, фиксируется в момент компиляции.

\section{Разработка библиотеки}

Итоговая диаграмма классов разрабатываемой библиотеки представлена ниже на рисунке \ref{fig:class-diagram}.


\myfigure[width=\columnwidth]{class-diagram}{Диграмма классов библиотеки}{fig:class-diagram}

Библиотека была реализована в соответствии с представленной диаграммой.
В данном отчёте не приводятся детали реализации отдельных методов, однако исходный код разработанной библиотеки находится в открытом доступе в специальном репозитории, вместе с примерами использования и тестирующими библиотеку программами для микроконтроллеров \cite{web:my-eemanager}.
Код содержит комментарии, необходимые для генерации документации средствами Doxygen \cite{web:doxygen}.

Работа библиотеки была протестирована на микроконтроллерах серии ESP8266 и платформы Arduino.
Проведённое тестирование показало, что логика библиотеки работает в соответствии с поставленными требованиями.
Однако, её интерфейс проявил себя крайне неудобным и недостаточно высокоуровневым.
Общий вид этого интерфейса был продиктован идеей сохранить частичную обратную совместимость с библиотекой EEManager и переиспользовать её код, что привело к предоставлению пользователю слишком низкоуровневых функций для работы с EEPROM-переменными. 
В то же время более высокоуровневые функции реализованы не были.

В дальнейшем необходимо, используя часть реализованных низкоуровневых функции, разработать обновлённую версию библиотеки, предоставляющую пользователю интерфейс более высокого уровня и не завязанную на использование библиотеки EEManager.
В обновлённой версии необходимо:
\begin{enumerate}
	\item Объединить в цельную сущность переменные в оперативной памяти и объекты, описывающие связанные с ними EEPROM-переменные. 
	При использовании такой сущности первоначальное считывание значения из EEPROM (или запись в него значения по умолчанию) возможно производить в конструкторе класса, соответствующего такой сущности.
	Дальнейшее же получение из неё пользовательских данных и их обновление в EEPROM реализовать за счёт переопределения операторов.
	Это позволить одновременно (с точки зрения пользователя) работать и с данными в оперативной памяти, и с их представлением в EEPROM.
	\item Заменить явное использование разделов неявным и позволить пользователю использовать большую глубину вложенности пространств имён.
	\item Реализовать механизм отложенной записи для всего EEPROM в целом, а не для каждой EEPROM-переменной по отдельности.
	\item Реализовать возможность немедленного обновления данных в EEPROM в случае необходимости.
\end{enumerate}
