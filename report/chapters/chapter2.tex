\chapter{Разработка библиотеки менеджера EEPROM}

\section{Уточнение требований к разрабатываемом библиотеке}

На основе требования об обеспечении независимости работы с EEPROM из различных программных модулей, с целью уменьшения количества коллизий пользовательских идентификаторов данных было принято решение реализовать следующее:
\begin{enumerate}
	\item Ввести иерархию идентификаторов блоков данных: не хранить все идентификаторы в едином пространстве имён, а создавать множество таких пространств и реализовать механизм обращения к ним по особым идентификаторам, которые должны быть уникальны между собой.
	\item Обязать разработчиков программных модулей, использующий разрабатываемую библиотеку, создавать для этих модулей отдельные пространства имён, идентификаторы в которых должны быть связаны с названием модуля, а непосредственно используемые блоки данных описывать внутри эти пространств имён.
	\item Обязать разработчиков самостоятельно поддерживать уникальность идентификаторов внутри отдельных моделей.
\end{enumerate}
Такой шаг позволит изолировать друг от друга идентификаторы, используемые различными разработчиками в различных программных модуля.
А вероятность коллизий идентификаторов пространств имён сама по себе не является большой.
Таким образом разработчики смогут использовать данную библиотеку, не задумываясь о других программных модулях, использующих её, что выполняет основное требование к разрабатываемой библиотеке.
В дальнейшем будем называть такие пространства имён разделами, а блоки данных, хранящиеся в EEPROM -- EEPROM-переменными.

На основе дополненного списка требований к библиотеке можно составить диаграмму прецедентов работы с данной библиотекой. Она представлена на рисунке \ref{fig:ucd}.

\myfigure[width=\columnwidth]{UCD}{Диаграммы прецедентов использования библиотеки}{fig:ucd}

На диаграмме отсутствует прецедент удаления переменной в связи с тем, что, как писалось выше, основное назначение применения EEPROM в программах для  микроконтроллеров -- сохранение состояния устройства между его запусками.
Как правило, для запуска микроконтроллера с одной и той же программой необходимы одни и те же данные, следовательно удалять их нет необходимости.

\section{Разработка структуры библиотеки}

\subsection{Общая структура библиотеки} \label{subsection:library-structure}

В соответствии с общепринятым стилем, библиотека должна быть написана с использованием объектно-ориентированной парадигмы программирования.
Основные понятия, которыми оперирует разрабатываемая библиотека -- раздел и EEPROM-переменная, следовательно, в библиотеке должны содержаться классы соответствующие этим понятиям.
Кроме того необходим отдельный класс оперирующий EEPROM в целом, назовём его классом менеджера памяти.

Для хранения EEPROM-переменных внутри разделов было решено использовать механизм, схожий с используемыми в файловых системах.
В описание раздела входит адрес первой EEPROM-переменной этого раздела, а в описание каждой переменной - адрес следующей переменной в этом же разделе либо специальное значение, если переменная последняя в разделе.
При этом для сохранения в EEPROM информации о разделах используется тот же механизм EEPROM-переменных.
Информация о разделе сохраняется в EEPROM за счёт создания EEPROM-переменной, связанной с объектом, описывающим этот раздел.
Для получения доступа разделам создаётся специальный системный раздел, который находится всегда по одному и тому же адресу в EEPROM и хранит в себе все EEPROM-переменные, связанные с другими разделами.
Кроме того, в этом разделе можно хранить последний использованный адрес для создания возможности добавлять новые разделы и переменные после перезапуска устройства.

Также стоит хранить специальное проверочное значение, показывающее, был ли менеджер инициализирован в EEPROM, и, в случае, если не был, инициализировать его.
Это необходимо для избежания чтения "мусорных" данный, находящихся в EEPROM до первого использования менеджера.
Также изменение этого значения в последующих версиях библиотеки можно использовать для принудительной переинициализации менеджера в случае изменения структуры хранения данных в этих версиях.
Графически логическая схема размещения данных в EEPROM показана на рисунке \ref{fig:logical-eeprom-data-structure}.

Для идентификации разделов и EEPROM-переменных было решено использовать произвольные строковые выражения -- имена.

\mysvg[inkscapelatex=false,width=\columnwidth]{logical-eeprom-data-structure}{логическая схема размещения данных в EEPROM}{fig:logical-eeprom-data-structure}


\subsection{Внешний интерфейс библиотеки}

С точки зрения пользователя библиотеки, её классы должны выглядеть как показано на рисунке \ref{fig:inerface-class-diagram}.
На данном рисунке EEPROMVar -- класс, описывающий EEPROM-переменную, её публичные методы взяты из соответствующего класса библиотеки EEManager (пункт \ref{section:eemanager}).
Его методы:
\begin{enumerate}
	\item updateNow -- мгновенная запись нового значения в EEPROM.
	\item update -- запланировать запись нового значения, то есть запустить таймер отложенной записи.
	\item tick -- метод, который необходимо вызывать регулярно, если используется отложенная запись: реальная запить нового значения EEPROM произойдёт при первом вызове метода tick() после истечения задержки записи.
	\item getTimeout -- вернуть текущее значение задержки записи.
	\item setTimeout -- установить новое значение задержки записи.
\end{enumerate}

Класс MemPart описывает раздел EEPROM, его метод getVar должен возвращать EEPROM-переменную с именем, равным значению параметра name, и связывать её с локальной переменной, хранящейся в оперативной памяти устройства, произвольного типа T, указателем на которую является параметр data.
В случае, если EEPROM-переменная с указанным названием уже содержится в данном разделе, её значение должно копироваться в локальную переменную по адресу data, преобразуясь в значение типа T.
Иначе, должна создаваться новая EEPROM-переменная, а значение локальной переменной записываться в неё.
При этом важно учитывать, что, так как локальная переменная связывается с EEPROM-переменной, область видимости локальной переменной должна быть не уже области видимости объекта класса EEPROMVar, полученного вызовом метода getVar.

Класс EEMemManager описывает менеджер памяти и имеет два статичных метода:
\begin{enumerate}
	\item init -- метод для инициализации менеджера.
	\item getMemPart -- метод, аналогичный методе getVar класса MemPart, но работающий с разделами, а не с переменными.
\end{enumerate}

\mysvg[inkscapelatex=false,width=\columnwidth]{interface-cd}{Диаграмма классов библиотеки с точки зрения её пользователя}{fig:inerface-class-diagram}

Таким образом итоговый алгоритм взаимодействия пользователя с библиотекой должен выглядеть следующим образом:
\begin{enumerate}
	\item Вызов метода EEMemManager.init при инициализации разрабатываемого программного модуля.
	\item Получение/создание раздела памяти вызовом метода EEMemManager.getMemPart с именем раздела, связанным с названием модуля.
	\item Создание переменных в оперативной памяти, значение которых необходимо сохранять в EEPROM.
	\item Получение/создание необходимых EEPROM-переменных и их связывание с переменными в оперативной памяти с помощью метода getVar полученного раздела.
	\item Вызов методов обновления значений EEPROM-переменных (updateNow или update и tick) по необходимости.
	\item Предполагается, что если для передачи сохраняемых данных между частями программного модуля будет использоваться переменная из оперативной памяти. Однако при необходимости, повторным вызовом метода MemPart.getVar возможно считать актуальное значение EEPROM-переменной.
\end{enumerate}


\subsection{EEPROM-переменные}

Помимо указателя на данные в оперативной памяти, которые необходимо сохранять, описание переменной должно включать значение задержки отложенной записи и мета-данные о записи переменной в EEPROM.
Эти данные приведены в таблице \ref{table:eeprom-var}.

\begin{center}
	\begin{longtable}{|p{0.2\columnwidth}|c|p{0.5\columnwidth}|}
		\caption{ \raggedright Мета-данные EEPROM-переменной}
		\label{table:eeprom-var}
		\\ \hline
		Размер & Название поля & Описание \\
		\hline \endfirsthead
		\subcaption{\raggedright Продолжение таблицы~\ref{tab:eeprom-var}}
		\\ \hline \endhead
		\hline \subcaption{Продолжение на след. стр.}
		\endfoot
		\hline \endlastfoot
		4 байта & nameHash & Хэш-значение имени переменной. Используется для фиксации объёма памяти, занимаемого именем. Хэш функция по-умолчанию - CRC32 \cite{article:crc-32} \\
		\hline
		2 байта & dataSize & Размер данных, хранящихся в переменной \\
		\hline
		2 байта & nextVarAddr & Адрес следующей переменной в этом же разделе \\
		\hline
		2 байта & addr & Адрес в EEPROM, по которому хранится переменная \\
	\end{longtable}
\end{center}

Все указанные выше поля переменной кроме адреса необходимо хранить в EEPROM, адрес же можно узнать в процессе поиска переменной и хранить только в оперативной памяти.
Для удобства записи и чтения мета-данных, те из них, которые необходимо хранить в EEPROM, следует вынести в отдельную структура -- VariableInfo.

\subsection{Разделы памяти}

Для удобства чтения и записи информации о разделе в EEPROM, все данные о разделе, которые необходимо сохранять между запусками, было решено вынести в отдельный класс -- MemPartInfo, а класс MemPart унаследовать от него.
В данной версии библиотеки к таким данным относится только адрес первой переменной раздела.

\subsection{Менеджер памяти}

Классу менеджера памяти необходимо хранить в EEPROM только последний использованный адрес.
Также ему необходимы следующие поля:
\begin{enumerate}
	\item lastAddr - последний использованный адрес.
	\item lastAddrVar - объект EEPROM-переменной для обновления последнего использованного адреса.
	\item metaMemPart - описанный в подпункте \ref{subsection:library-structure} системный раздел памяти.
	\item startAddr - стартовый адрес в EEPROM, используемый менеджером. По умолчанию равен нулю, то есть используется весь доступный объём EEPROM.
\end{enumerate}

В энергонезависимой памяти из этих значений необходимо хранить только последний использованный адрес: стартовый адрес и адрес, по которому хранится описание системного раздела устанавливаются в момент компиляции.

\section{Разработка библиотеки}

Итоговая диаграмма классов разрабатываемой библиотеки представлена ниже на рисунке \ref{fig:class-diagram}.


\myfigure[width=\columnwidth]{class-diagram}{Диграмма классов библиотеки}{fig:class-diagram}

Библиотека была реализована в соответствии с представленной диаграммой.
В данном отчёте не приводятся детали реализации отдельных методов, однако исходный код разработанной библиотеки находится в открытом доступе в специальном репозитории \cite{web:my-eemanager}.
Код содержит комментарии, необходимые для генерации документации средствами Doxygen \cite{web:doxygen}.

Работа библиотеки была протестирована для всех прецедентов использования на микроконтроллерах серии ESP8266 и платформы Arduino.
Исходный код тестирующих библиотеку программ для микроконтроллеров также выложен в открытый доступ вместе с библиотекой.

Кроме того, репозиторий содержит примеры использования разработанной библиотеки.
Базовый пример использования также находится в приложении \ref{}.
