\chapter{Анализ наиболее популярных решений управления энергонезависимой памятью}

\section{Требования к системе управления энергонезависимой памятью} \label{section:requirements}

В платформе SciVi в основном применяются микроконтроллеры серии ESP8266. А для их программирования используются инструменты среды разработки Arduino IDE, позволяющие программировать микроконтроллеры, используя язык программирования C++, а также специальное дополнение к этой среде для работы с ESP8266 \cite{web:esp-core}, содержащее, в частности, набор “стандартных” библиотек.

Таким образом, необходимый программный модуль должен представлять собой библиотеку классов языка программирования C++, может использовать стандартный набор библиотек Arduino IDE и указанного дополнения к ней.
Такая библиотека должна:
\begin{enumerate}
	\item Предоставлять пользователю возможность сохранять и считывать данные из EEPROM микроконтроллера. При этом:
	\begin{enumerate}
		\item Данные могут иметь произвольную структуру.
		\item Доступ к ним должен производиться по некоторым  идентификаторам, уникальным для различных данных и без необходимости ручных манипуляций с адресами EEPROM со стороны пользователя.
	\end{enumerate}
	\item Автоматически определять факт наличия в EEPROM данных с заданным идентификатором, определять адрес для записи новых данных, сохранять в EEPROM метаданные о хранящихся данных для их использования после перезапуска микроконтроллера.
	\item Минимизировать количество операций записи в EEPROM, т.к. каждая ячейка такой памяти может быть перезаписана ограниченное количество раз (обычно производители гарантируют от 100.000 до 1.000.000 циклов перезаписи), после чего выходит из строя.
	\item Выполняться на микроконтроллерах серии ESP8266 и, по возможности, на платформе Arduino, так как эта платформа является наиболее популярной и распространённой.
\end{enumerate}

Ключевым требованием является полная автоматизация работы с адресами EEPROM, это необходимо для создания возможности использования EEPROM в различных независимых программных модулях.
В противном случае, таким модулям понадобилось бы каким-либо образом обмениваться информацией об используемых ими адресах для избежания чтения и записи разными модулями в одни и те же ячейки EEPROM.


\section{Стандартная библиотека}

В стандартный набор библиотек Arduino IDE уже входит библиотека для работы с EEPROM \cite{web:arduino-eeprom}.
Однако она предоставляет только простые функции, такие как записать и считать байт по указанному адресу.
Позже в неё были добавлены функции для чтения и записи данных произвольных типов, но также только по явно указанному адресу.
Очевидно, это делает стандартную библиотеку нарушающей все поставленные требования, однако её функции можно использовать в качестве низкоуровневого интерфейса EEPROM в разрабатываемой библиотеке.
Кроме указанных, стандартная библиотека содержит функцию-обёртку вокруг функции записи, производящую фактическую перезапись данных только тогда, когда они отличаются от хранящихся по указанному адресу в данный момент.
В дальнейшем, в большинстве случаев, разумно использовать для записи именно эту функцию с целью уменьшения износа EEPROM.


\section{Библиотека EEManager} \label{section:eemanager}

Как и SciVi в данный момент, большая часть проектов, хранящих какие-либо данные в EEPROM, ограничивается использованием стандартной библиотеки.
И до недавнего времени в открытом доступе отсутствовали более высокоуровневые альтернативы.
Однако не так давно появилась новая библиотека для работы с EEPROM -- EEManager \cite{web:eemanager}.
Она имеет открытый исходный код (опубликован под лицензией MIT \cite{web:MIT}) и документацию на русском языке.

Данная библиотека имеет следующие преимущества:
\begin{itemize}
	\item Реализован механизм отложенной записи: по умолчанию данные записываются в EEPROM с заданной задержкой после последней команды на запись. Использование такого подхода имеет смысл в ситуациях, когда данные должны перезаписываться много раз за короткий промежуток времени, в действительности же, с таким механизмом данные в EEPROM будут записаны только в последний раз, что значительно замедлит износ памяти. В то же время этот механизм имеет значительный недостаток: если потеря питания произойдёт после команды записи, но до истечения задержки, новые данные записаны не будут. Это делает использование такого механизма оправданным только в устройствах, для которых гарантия записи не является обязательной и точность восстановления состояния после потери питания не представляет критической важности.
	\item Библиотека также реализует "механизм ключа первой записи". Вместе с каждым блоком данных в EEPROM хранится специальный однобайтовый ключ. При обращении к блоку данных пользователь указывает придуманный им ключ, который не должен изменяться от запуска к запуску, а из EEPROM считывается записанное значение ключа. Если они совпадают, значит необходимые данные уже находятся в EEPROM и их необходимо только считать, иначе данные никогда не были записаны, в этом случае данные должны быть сохранены в EEPROM.
\end{itemize}

Работа с данной библиотекой осуществляется следующим образом:
\begin{enumerate}
	\item Создаётся переменная в энергозависимой памяти, значение которой необходимо хранить в EEPROM.
	\item Создаётся специальный объект, описывающий блок EEPROM. При этом пользователь указывает переменную в энергозависимой памяти, значение которой  необходимо хранить, и адрес в EEPROM, начиная с которого должна быть записана эта переменная.
	\item С помощью механизма ключа первой записи либо в EEPROM записывается значение переменной по умолчанию, либо наоборот сохранённое в EEPROM значение считывается в переменную.
	\item В дальнейшем, по необходимости, текущее значение переменной записывается в EEPROM. Для этого у описанного выше объекта существует два метода: для немедленной записи и для запуска таймера записи с задержкой.
\end{enumerate}

Несмотря на указанные преимущества перед стандартной библиотекой, библиотека EEManager так же не может быть использована в готовом виде, так как обращение к блокам данных в ней производится только по их адресам.
Это делает невозможным независимое использование данной библиотеки из различных программных модулей.


\section{Библиотека EEPROMWearLevel}

В большинстве микроконтроллеров, в частности, на платформе Arduino, используется EEPROM с возможностью перезаписи отдельного байта, таким образом одни ячейки памяти могут изнашиваться быстрее других.
Для уменьшения скорости общего износа памяти имеет смысл как можно равномернее распределять количество циклов перезаписи по всем ячейкам EEPROM.
Классический способ такого распределения -- использование кольцевого буфера \cite{web:circular-buffer}.

Идея этого метода заключается в перезаписи данных не по тому же адресу, а по новому, с некоторым сдвигом вперёд. Когда такой сдвиг становится невозможным из-за недостаточного объёма памяти, запись снова производится по первоначальному адресу.
При этом, чтобы иметь доступ к данным, необходимо постоянно хранить их текущий адрес или счётчик циклов перезаписи, и определять адрес по его значению.
В самом простом случае, если все данные хранятся в одном блоке, это можно сделать, умножив номер цикла на размер этого блока данных.
Однако, если хранить их по фиксированному адресу в EEPROM, соответствующие ячейки будут изнашиваться быстрее, что сделает использование кольцевого буфера бессмысленным.

Один из способов эффективной реализации счётчика -- использование двух кольцевых буферов: одного для данных, второго -- для счётчика.
Если при этом каждый раз при прохождении целого цикла записи (записи данных по изначальному адресу) для второго буфера, заполнять его нулевыми значениями, то после перезапуска микроконтроллера в этом буфере можно найти актуальное значение счётчика тривиальным образом -- это будет последнее ненулевое значение в нём.

Другой способ основывается на использовании ещё одной особенности EEPROM микроконтроллеров: после стирания байта все его биты устанавливаются равными единице, и стандартная библиотека Arduino IDE предоставляет возможность устанавливать отдельным битам нулевое значение, без стирания всего байта.
За счёт этого можно хранить счётчик в своеобразной унарной системе счисления: десятичное значение счётчика равно количеству нулей в его побитовой записи.
Это позволит стирать ячейки EEPROM, хранящие счётчик, только при прохождении полного цикла записи в буфере данных.

Кольцевой буфер с последним из описанных механизмом эффективного счётчика реализует открытая библиотека EEPROMWearLevel \cite{web:eeprom-wear-level} (опубликована под лицензией Apache 2.0 \cite{web:apache-license-2.0}).
EEPROMWearLevel предоставляет интерфейс, аналогичный стандартной библиотеке, за исключением функции инициализации, в которую в данной библиотеке необходимо подать требуемое количество блоков EEPROM, дополняя этот интерфейс возможностью обращения к блокам данных по их индексам.
Указанное отличие в функциях инициализации вызвано тем, что данная библиотека создаёт отдельный кольцевой буфер для каждого блока данных, при этом весь объём EEPROM делится на буферы поровну между всеми хранящимися блоками данных.
Такое решение является неэффективным в случае хранения блоков разного размера.
В худшем случае размер одного или нескольких блоков может превышать размеры выделенного буфера, однако такой случай обрабатывается библиотекой и приведёт к выводу соответствующей ошибки и отмене записи такого блока.
Целостность других блоков при этим нарушена не будет.

Индексы блоков данных, используемые в этой библиотеке для доступа к ним, можно считать уникальными идентификаторами, описанными в требованиях, приведённых в начале главы.
Однако необходимость общей инициализации с указанием суммарного количества блоков данных делает невозможным применение данной библиотеки в независимых программных модулях.
Такой необходимости можно избежать, например, введя иерархическую структуру разделения EEPROM: сначала разделить весь объём EEPROM на крупные разделы (по одному или несколько на модуль), а затем внутри каждого из них -- на кольцевые буферы, аналогично уже реализованному принципу.
Чтобы гарантировать, что потребности всех модулей в использовании EEPROM учтены, необходимо:
\begin{itemize}
	\item Либо проводить разделение EEPROM только после того, как все модули (посредством вызова некоторой специальной функции) сообщат библиотеке управления EEPROM их потребности в использовании EEPROM. Однако такой подход требует обязать конечного пользователя вызывать функцию инициализации библиотеки управления EEPROM строго после инициализации всех модулей, которым она необходима. А разработчиков этих модулей -- вызывать функцию, описанную выше, при их инициализации. Такой подход, очевидно, является неудобным, так как требует от конечного пользователя знания о том, необходимо ли используемым им модулям хранить данные в EEPROM.
	\item Либо реализовать возможности динамического добавления новых разделов EEPROM, при этом уменьшая размер уже созданных разделов. Такой подход лишён недостатков первого, однако его использование значительно усложнит работу библиотеки из-за необходимости уменьшения размеров каждого кольцевого буфера при добавлении нового раздела и, возможно, сдвига данных, если эти данные в момент добавления выходят за уменьшенные границы буфера.
\end{itemize}

Можно заключить, что существует возможность дополнения данной библиотеки таким образом, чтобы она удовлетворяла всем поставленным требованиям.
В то же время данная библиотека не может напрямую использоваться с микроконтроллерами ESP8266, так как она содержит платформозависимый код, выполнение которого возможно только микроконтроллерами с архитектурой AVR, к которым ESP8266 не относится.
Кроме того, микроконтроллеры ESP8266 используют иной тип EEPROM -- flash память \cite{web:esp-eeprom-src, web:usage-of-esp-eeprom}, которая не позволяет стирать и перезаписывать отдельные байты, а только их большие группы (обычно от 512 байт) \cite{incollection:flash-memory}.
Основное назначение этой памяти в данных микроконтроллерах -- хранение исполняемых программ, однако её часть специально выделена для хранения пользовательских данных.
При этом в ходе анализа исходного кода стандартной библиотеки \cite{web:esp-eeprom-src} для работы с EEEPROM для ESP8266 было установлено, что для данных микроконтроллеров размер такой группы байт равен всему объёму flash-памяти, выделенному для пользовательских данных.

Таким образом, оказалось, что использование в программах для ESP8266 любых механизмов, подобных кольцевым буферам, не только не приводит к замедлению износа памяти, но и способно ускорять её износ из-за дополнительных операций перезаписи счётчиков и других метаданных.

\section{Вывод}

В ходе первого этапа работы были изучены особенности устройства и работы EEPROM.
Были составлены требования к программному модулю для работы с EEPROM микроконтроллеров.
С учётом этих требований были проанализированы существующие в открытом доступе решения.
На основе анализа было принято решение о разработке собственного модуля, а также об использовании в нём стандартной библиотеки для работы с EEPROM и механизма отложенной записи из библиотеки EEManager.
