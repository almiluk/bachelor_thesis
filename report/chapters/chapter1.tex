\chapter{Анализ наиболее популярных решений управления энергонезависимой памятью}

\section{Требования к системе управления энергонезависимой памятью} \label{section:requirements}

В платформе SciVi в основном применяются микроконтроллеры серии ESP8266. А для их программирования используются инструменты среды разработки Arduino IDE, позволяющие программировать микроконтроллеры, используя язык программирования C++, а также специальное дополнение к этой среде для работы с ESP8266 \cite{web:esp-core}, содержащее, в частности, набор "`стандартных"' библиотек.

Таким образом, необходимый программный модуль должен представлять собой библиотеку классов языка программирования C++, может использовать стандартный набор библиотек Arduino IDE и указанного дополнения к ней.
Такая библиотека должна:
\begin{enumerate}
	\item Предоставлять пользователю возможность сохранять и считывать данные из EEPROM микроконтроллера. При этом:
	\begin{enumerate}
		\item Данные могут иметь произвольную структуру.
		\item Доступ к ним должен производиться по некоторым  идентификаторам, уникальным для различных данных и без необходимости ручных манипуляций с адресами EEPROM со стороны пользователя.
	\end{enumerate}
	\item Автоматически определять факт наличия в EEPROM данных с заданным идентификатором, определять адрес для записи новых данных, сохранять в EEPROM метаданные о хранящихся данных для их использования после перезапуска микроконтроллера.
	\item Минимизировать количество операций записи в EEPROM, т.к. каждая ячейка такой памяти может быть перезаписана ограниченное количество раз (обычно производители гарантируют от 100.000 до 1.000.000 циклов перезаписи), после чего выходит из строя.
	\item Выполняться на микроконтроллерах серии ESP8266 и, по возможности, на платформе Arduino, так как эта платформа является наиболее популярной и распространённой.
\end{enumerate}

Ключевым требованием является полная автоматизация работы с адресами EEPROM, это необходимо для создания возможности использования EEPROM в различных независимых программных модулях.
В противном случае, таким модулям понадобилось бы каким-либо образом обмениваться информацией об используемых ими адресах для избежания чтения и записи разными модулями в одни и те же ячейки EEPROM.


\section{Стандартная библиотека}

В стандартный набор библиотек Arduino IDE уже входит библиотека для работы с EEPROM \cite{web:arduino-eeprom}.
Как и SciVi в данный момент, большая часть проектов, хранящих какие-либо данные в EEPROM, ограничивается использованием этой библиотеки.
Однако она предоставляет только простые функции, такие как записать и считать байт по указанному адресу.
Позже в неё были добавлены функции для чтения и записи данных произвольных типов, но также только по явно указанному адресу.
Очевидно, это делает стандартную библиотеку нарушающей все поставленные требования, однако её функции можно использовать в качестве низкоуровневого интерфейса EEPROM в разрабатываемой библиотеке.
Кроме указанных, стандартная библиотека содержит функцию-обёртку вокруг функции записи, производящую фактическую перезапись данных только тогда, когда они отличаются от хранящихся по указанному адресу в данный момент.
В дальнейшем, в большинстве случаев, разумно использовать для записи именно эту функцию с целью уменьшения износа EEPROM.


\section{Библиотека EEPROMEx}

Библиотека EEPROMEx (от англ. Extended~--- Расширенный)~--- одна из первых разработок для работы с EEPROM микроконтроллеров в среде Arduiono IDE \cite{web:eepromex}.
Данная библиотека была создана раньше, чем описанная выше, поэтому часть предоставляемых ими возможностей совпадает, однако реализованы они независимо друг от друга.
EEPROMEx содержит функции для чтения и записи в EEPROM данных некоторых стандартных типов: целочисленных беззнаковых чисел длиной в 8, 16 и 32 бита и 32-х и 64-х битных чисел с плавающей точкой.
В библиотеке также содержатся функции для чтений и записи отдельных битов и, как и в стандартной библиотеке, аналогичные функции для работы с данными пользовательских типов и аналоги всех функций записи, производящие запись только при отличии данных.
Кроме того EEPROMEx содержит и уникальную возможность~--- с помощью класса EEPROMVar связывать одним объектом переменные в коде программы и данные в EEPROM (их адреса).
Причём эти адреса назначаются автоматически, что косвенно соответствует части требований, описанных в пункте \ref{section:requirements}.
Рассмотрим пример использования EEPROMVar, демонстрирующий большую часть возможностей данного класса:

\lstinputlisting[language=C++]{resources/code_listings/EEPROMex-var-example.cpp}

%\begin{lstlisting} %\begin{verbatim}

%\end{lstlisting}

Как можно увидеть в строке 1 примера, при создании объекта класса EEPROMVar указывается тип данных, которые необходимо хранить (в примере~--- float), и значение по умолчанию, которое передаётся в конструктор в виде параметра (в примере~--- 5.5).
Метод restore, вызываемый в строке 3, считывает из EEPROM данные, соответствующие данному объекту, и сохраняет в него эти данные .
В строке 5 демонстрируется возможность изменения хранимых данных с помощью оператора присвоения, причём в качестве левостороннего значения выступает объект класса EEPROMVar, а правостороннего~--- значение хранимого объектом типа пользовательских данных.
Это достигается за счёт переопределения оператора присвоения для данного класса.
В строке 7 показан обратный переход: объект класса EEPROMVar может быть переведёт в значение хранимого им типа.
В последней строке показан вызов метода save, сохраняющего значение, хранящееся в объекте, в EEPROM.

Также для класса EEPROMVar определены некоторые операторы, такие как оператор инкремента (++), присвоения со сложением (+=) и другие операторы, связанные с изменением хранимого значения.
Такие операторы вызывают в своём теле аналогичные для хранимых данных, что, разумеется, требует их существования.

Описанный класс механизм имеет ряд значительных недостатка.
Первый из них заключается в способе связывания данных и адреса, по которому они хранятся в EEPROM.
Обычно для этого данным выдаются уникальные имена, и каким-либо образом сохраняется информация о том, что данные с определённым именем находятся по определённому адресу.
Как можно увидеть в приведённом примере, при использовании библиотеки EEEPROMEx присвоения имён не происходит.
В этом случае данные располагаются в EEPROM друг за другом в порядке создания объектов класса EEPROMVar.
Таким образом, для того, чтобы гарантировать, что при перезапуске микроконтроллера объекты класса EEPROMVar связываются с одними и теме же адресами в EEPROM, необходимо обеспечивать создание этих объектов в строго одинаковом порядке при каждом включении устройства.
Эта работа ложится на плечи конечного пользователя~--- разработчика программы для микроконтроллера.
Причём даже в случае, если разработчик не применяет описываемый класс напрямую, но он используется в импортируемых итоговой программой библиотеках.

Второй проблемой является невозможность определения первого вызова конструктора для каких-либо пользовательских данных, то есть момента, в который эти данные отсутствуют в EEPROM, и необходимо записать значение по умолчанию.
И вновь разработчик конечной программы должен каким-либо образом самостоятельно определять, когда после создания объекта необходимо проводить сохранение в EEPROM значения по умолчанию, а когда наоборот считывание уже хранящегося в памяти значения.

В конечном итоге можно сделать вывод, что библиотека EEPROMEx частично соответствует предъявляемым требования, но при этом её использование нельзя назвать удобным, так как оно требует от конечного пользователя большой работы, которая могла бы быть автоматизирована.
При этом идея использовать переопределение операторов для получения и изменения пользовательских данных в EEPROM является крайне удачной и удобной в использовании.
Такой вариант предпочтительнее использования для тех же целей отдельных методов, так как, во-первых, позволяет пользователю библиотеки писать меньше кода и, во-вторых, позволяет ему думать об объекте, описывающем данные в EEPROM, как о самих этих данных.
В дальнейшем при разработке собственной библиотеки имеет смысл реализовать аналогичный интерфейс.


\section{Библиотека EEManager} \label{section:eemanager}

Сравнительно недавно была опубликована новая библиотека для работы с EEPROM~--- EEManager \cite{web:eemanager}.
Она имеет открытый исходный код (опубликован под лицензией MIT \cite{web:MIT}) и документацию на русском языке.
Так как данная библиотека значительно новее предыдущей рассмотренной, и в момент её создания уже существовала описанная выше версия стандартной библиотека, EEManager используют её возможности, в первую очередь - функции-обёртки, уменьшающие износ памяти.

Данная библиотека имеет следующие преимущества:
\begin{itemize}
	\item Реализован механизм отложенной записи: по умолчанию данные записываются в EEPROM с заданной задержкой после последней команды на запись. Использование такого подхода имеет смысл в ситуациях, когда данные должны перезаписываться много раз за короткий промежуток времени, в действительности же, с таким механизмом данные в EEPROM будут записаны только в последний раз, что значительно замедлит износ памяти. В то же время этот механизм имеет значительный недостаток: если потеря питания произойдёт после команды записи, но до истечения задержки, новые данные записаны не будут. Это делает использование такого механизма оправданным только в устройствах, для которых гарантия записи не является обязательной и точность восстановления состояния после потери питания не представляет критической важности.
	\item Библиотека также реализует "`механизм ключа первой записи"'. Вместе с каждым блоком данных в EEPROM хранится специальный однобайтовый ключ. При обращении к блоку данных пользователь указывает придуманный им ключ, который не должен изменяться от запуска к запуску, а из EEPROM считывается записанное значение ключа. Если они совпадают, значит необходимые данные уже находятся в EEPROM и их необходимо только считать, иначе данные никогда не были записаны, в этом случае данные должны быть сохранены в EEPROM.
\end{itemize}

Работа с библиотекой осуществляется следующим образом:
\begin{enumerate}
	\item Создаётся переменная в энергозависимой памяти, значение которой необходимо хранить в EEPROM.
	\item Создаётся специальный объект, описывающий блок данных EEPROM (некоторый аналог EEPROMVar из библиотеки EEEPROMEx). 
	При этом пользователь указывает переменную в энергозависимой памяти, значение которой  необходимо хранить, и адрес в EEPROM, начиная с которого должна быть записана эта переменная.
	\item С помощью механизма ключа первой записи либо в EEPROM записывается значение переменной по умолчанию, либо наоборот сохранённое в EEPROM значение считывается в переменную.
	\item В дальнейшем, по необходимости, текущее значение переменной записывается в EEPROM. 
	Для этого необходимо сначала обновить значение энергозависимой переменной, с которой связан описанный выше объект, а затем записать это новое значение в EEPROM.
	Чтобы сделать это, можно воспользоваться одним из двух методов: для немедленной записи и для запуска таймера записи с задержкой.
\end{enumerate}

Несмотря на указанные преимущества перед стандартной библиотекой, библиотека EEManager так же не может быть использована в готовом виде, так как обращение к блокам данных в ней производится только по их адресам.
Это делает невозможным независимое использование данной библиотеки из различных программных модулей.


\section{Библиотека EEPROMWearLevel}

В большинстве микроконтроллеров, в частности, на платформе Arduino, используется EEPROM с возможностью перезаписи отдельного байта, таким образом одни ячейки памяти могут изнашиваться быстрее других.
Для уменьшения скорости общего износа памяти имеет смысл как можно равномернее распределять количество циклов перезаписи по всем ячейкам EEPROM.
Классический способ такого распределения~--- использование кольцевого буфера \cite{web:circular-buffer}.

Идея этого метода заключается в перезаписи данных не по тому же адресу, а по новому, с некоторым сдвигом вперёд. Когда такой сдвиг становится невозможным из-за недостаточного объёма памяти, запись снова производится по первоначальному адресу.
При этом, чтобы иметь доступ к данным, необходимо постоянно хранить их текущий адрес или счётчик циклов перезаписи, и определять адрес по его значению.
В самом простом случае, если все данные хранятся в одном блоке, это можно сделать, умножив номер цикла на размер этого блока данных.
Однако, если хранить их по фиксированному адресу в EEPROM, соответствующие ячейки будут изнашиваться быстрее, что сделает использование кольцевого буфера бессмысленным.

Один из способов эффективной реализации счётчика~--- использование двух кольцевых буферов: одного для данных, второго~--- для счётчика.
Если при этом каждый раз при прохождении целого цикла записи (записи данных по изначальному адресу) для второго буфера, заполнять его нулевыми значениями, то после перезапуска микроконтроллера в этом буфере можно найти актуальное значение счётчика тривиальным образом~--- это будет последнее ненулевое значение в нём.

Другой способ основывается на использовании ещё одной особенности EEPROM микроконтроллеров: после стирания байта все его биты устанавливаются равными единице, и стандартная библиотека Arduino IDE предоставляет возможность устанавливать отдельным битам нулевое значение, без стирания всего байта.
За счёт этого можно хранить счётчик в своеобразной унарной системе счисления: десятичное значение счётчика равно количеству нулей в его побитовой записи.
Это позволит стирать ячейки EEPROM, хранящие счётчик, только при прохождении полного цикла записи в буфере данных.

Кольцевой буфер с последним из описанных механизмом эффективного счётчика реализует открытая библиотека EEPROMWearLevel \cite{web:eeprom-wear-level} (опубликована под лицензией Apache 2.0 \cite{web:apache-license-2.0}).
EEPROMWearLevel предоставляет интерфейс, аналогичный стандартной библиотеке, за исключением функции инициализации, в которую в данной библиотеке необходимо подать требуемое количество блоков EEPROM, дополняя этот интерфейс возможностью обращения к блокам данных по их индексам.
Указанное отличие в функциях инициализации вызвано тем, что данная библиотека создаёт отдельный кольцевой буфер для каждого блока данных, при этом весь объём EEPROM делится на буферы поровну между всеми хранящимися блоками данных.
Такое решение является неэффективным в случае хранения блоков разного размера.
В худшем случае размер одного или нескольких блоков может превышать размеры выделенного буфера, однако такой случай обрабатывается библиотекой и приведёт к выводу соответствующей ошибки и отмене записи такого блока.
Целостность других блоков при этим нарушена не будет.

Индексы блоков данных, используемые в этой библиотеке для доступа к ним, можно считать уникальными идентификаторами, описанными в требованиях, приведённых в начале главы.
Однако необходимость общей инициализации с указанием суммарного количества блоков данных делает невозможным применение данной библиотеки в независимых программных модулях.
Такой необходимости можно избежать, например, введя иерархическую структуру разделения EEPROM: сначала разделить весь объём EEPROM на крупные разделы (по одному или несколько на модуль), а затем внутри каждого из них~--- на кольцевые буферы, аналогично уже реализованному принципу.
Чтобы гарантировать, что потребности всех модулей в использовании EEPROM учтены, необходимо:
\begin{itemize}
	\item Либо проводить разделение EEPROM только после того, как все модули (посредством вызова некоторой специальной функции) сообщат библиотеке управления EEPROM их потребности в использовании EEPROM. Однако такой подход требует обязать конечного пользователя вызывать функцию инициализации библиотеки управления EEPROM строго после инициализации всех модулей, которым она необходима. А разработчиков этих модулей~--- вызывать функцию, описанную выше, при их инициализации. Такой подход, очевидно, является неудобным, так как требует от конечного пользователя знания о том, необходимо ли используемым им модулям хранить данные в EEPROM.
	\item Либо реализовать возможности динамического добавления новых разделов EEPROM, при этом уменьшая размер уже созданных разделов. Такой подход лишён недостатков первого, однако его использование значительно усложнит работу библиотеки из-за необходимости уменьшения размеров каждого кольцевого буфера при добавлении нового раздела и, возможно, сдвига данных, если эти данные в момент добавления выходят за уменьшенные границы буфера.
\end{itemize}

Можно заключить, что существует возможность дополнения данной библиотеки таким образом, чтобы она удовлетворяла всем поставленным требованиям.
В то же время данная библиотека не может напрямую использоваться с микроконтроллерами ESP8266, так как она содержит платформозависимый код, выполнение которого возможно только микроконтроллерами с архитектурой AVR, к которым ESP8266 не относится.
Кроме того, микроконтроллеры ESP8266 используют иной тип EEPROM~--- flash память \cite{web:esp-eeprom-src, web:usage-of-esp-eeprom}, которая не позволяет стирать и перезаписывать отдельные байты, а только их большие группы (обычно от 512 байт) \cite{incollection:flash-memory}.
Основное назначение этой памяти в данных микроконтроллерах~--- хранение исполняемых программ, однако её часть специально выделена для хранения пользовательских данных.
При этом в ходе анализа исходного кода стандартной библиотеки \cite{web:esp-eeprom-src} для работы с EEEPROM для ESP8266 было установлено, что для данных микроконтроллеров размер такой группы байт равен всему объёму flash-памяти, выделенному для пользовательских данных.

Таким образом, оказалось, что использование в программах для ESP8266 любых механизмов, подобных кольцевым буферам, не только не приводит к замедлению износа памяти, но и способно ускорять её износ из-за дополнительных операций перезаписи счётчиков и других метаданных.

\section{Вывод}

В ходе первого этапа работы были изучены особенности устройства и работы EEPROM.
Были составлены требования к программному модулю для работы с EEPROM микроконтроллеров.
С учётом этих требований были проанализированы существующие в открытом доступе решения.
На основе анализа было принято решение о разработке собственного модуля, а также об использовании в нём стандартной библиотеки для работы с EEPROM и целесообразности заимствования некоторых механизмов из других библиотек.
