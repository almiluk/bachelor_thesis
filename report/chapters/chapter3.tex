\chapter{Разработка библиотеки менеджера EEPROM}

\section{Первая версия библиотеки}

После анализа существующих решений, была разработана собственная библиотека.
Её исходный код находится в открытом доступе в специальном репозитории, вместе с примерами использования и тестирующими библиотеку программами для микроконтроллеров \cite{web:my-eemanager}.
Разработанная библиотека основывалась только на библиотеке EEManager, которая на тот момент казалась наиболее удачной из рассмотренных библиотек.
Однако после реализации и тестирования было установлено, что логика созданной библиотеки работает в соответствии с поставленными требованиями, но её интерфейс проявил является крайне неудобным и недостаточно высокоуровневым.
Общий вид этого интерфейса был продиктован идеей сохранить частичную обратную совместимость с библиотекой EEManager и переиспользовать её код, что привело к предоставлению пользователю недостаточно высокоуровневых функций.

Основным понятием, которой оперировала данная библиотека является EEPROM-переменная~--- сущность (программный объект), описывающая некоторый единый блок пользовательских данных, хранимых в EEPROM.
В дальнейшей работе также использовалось это понятие.

% TODO: ОПИСАТЬ ЧУТЬ ПОДРОБНЕЕ.
% TODO: ДОБАВИТЬ ДИАГРАММУ КЛАССОВ ВНЕШНЕГО ИНТЕРФЕЙСА БИБЛИОТЕКИ.

\section{Уточнение требований к разрабатываемой библиотеке}

После признания первой версии библиотеки неудачной, было принято решение о разработке второй со следующими изменениями:

\begin{enumerate}
	\item Объединить одной сущностью данные в оперативной памяти и объекты, описывающие связанные с ними данные в EEPROM.
	При использовании такой сущности первоначальное считывание значения из EEPROM (или запись в него значения по умолчанию) возможно производить в конструкторе класса, соответствующего такой сущности.
	Дальнейшее же получение из неё пользовательских данных и их обновление в EEPROM реализовать за счёт переопределения операторов, аналогично классу EEPROMVar из библиотеки EEPROMEx.
	Это позволить одновременно (с точки зрения пользователя) работать и с данными в оперативной памяти, и с их представлением в EEPROM.
	% \item Заменить явное использование разделов неявным и позволить пользователю использовать большую глубину вложенности пространств имён.
	\item Реализовать механизм отложенной записи для всего EEPROM в целом, а не для каждой EEPROM-переменной по отдельности.
	\item Завязать такой механизм на количестве обращений на запись, а не на реальном времени, как в EEManager.
	\item Реализовать возможность немедленного обновления данных в EEPROM в случае необходимости.
\end{enumerate}

На основе дополненного списка требований к библиотеке можно составить диаграмму прецедентов работы с ней. Она представлена на рисунке \ref{fig:ucd}.

\myfigure[width=\columnwidth]{UCD}{Диаграммы прецедентов использования библиотеки}{fig:ucd}

На диаграмме отсутствует прецедент удаления переменной в связи с тем, что, как писалось выше, основная цель применения EEPROM в программах для  микроконтроллеров~--- сохранение состояния устройства между его запусками.
Как правило, для запуска микроконтроллера с одной и той же программой необходимы одни и те же данные, следовательно, удалять их нет необходимости.

\section{Разработка структуры библиотеки}

\subsection{Общая структура библиотеки} \label{subsection:library-structure}

В соответствии с общепринятым стилем, библиотека должна быть написана с использованием объектно-ориентированной парадигмы программирования.
Основное понятие для разрабатываемой библиотеки~--- EEPROM-переменная, следовательно, в ней должен содержаться класс, соответствующий этому понятию.
Кроме того, необходим отдельный класс, оперирующий EEPROM в целом. Назовём его классом менеджера памяти.
К этому классу должны обращаться EEPROM-переменные для их поиска или добавления в память и обновления их значений.

Важно учитывать, что стандартные библиотеки EEPROM для различных микроконтроллеров обычно работают схожим образом, но всё же могут иметь отличая.
В частности незначительно отличаются такие библиотеки и для целевых платформ данной работы~--- Arduino и ESP8266.
В следствии этого необходимо вынести все операции, использующие функции этих библиотек в отдельную сущность с тем, чтобы была возможность легко её изменить для использования других микроконтроллеров.
Удобнее всего это сделать, определив абстрактный класс, предоставляющий унифицированные методы-обёртки над стандартными функциями, и создав конкретные реализации такого класса для различных микроконтроллеров.
Этот же класс должен реализовывать механизмы уменьшения износа памяти, так как они могут быть различными для различных микроконтроллеров.
Такой подход также позволит легче адаптировать разрабатываемую библиотеку для использования с абсолютно другими микроконтроллерами.

Для хранения EEPROM-переменных было решено использовать механизм, схожий с механизмами, используемыми в файловых системах.
В описание каждой переменной включается адрес следующей, либо специальное значение, обозначающее, что данная переменная является последней в разделе.
Адрес первой же переменной является константой и не изменяется при перезапуске устройства.

Также в энергонезависимой памяти стоит хранить специальное проверочное значение, показывающее, был ли менеджер инициализирован в EEPROM, и, в случае, если не был, инициализировать его.
Причём имеет смысл объявить два таких значения, оба из которых свидетельствуют о том, что менеджер инициализирован, но одно из них используется в случае, если в EEPROM была объявлена хотя бы одна переменная, в противном случае, используется второе значение.
Использование такого механизма необходимо для избежания чтения "`мусорных"' данных, находящихся в EEPROM до первого использования менеджера.
Также изменение этого значения в последующих версиях библиотеки можно использовать для принудительной переинициализации менеджера в случае изменения структуры хранения данных при выходе новой версии.

Принудительная переинициализация менеджера также требуется и при перепрошивке микроконтроллера в противном случае в энергонезависимой памяти будут накапливаться неиспользуемые переменные от предыдущих программ, загруженных в устройство.
Arduino IDE автоматически создаёт константы, описывающие время компиляции программы и доступные из её кода.
Это время можно также сохранять в EEPROM и при запуске микроконтроллера проверять, совпадает ли время компиляции текущей программы с сохранённым временем.
Если они отличны, переинициализацировать менеджер, считая, что больше в EEPROM нет сохранённых переменных.
Для хранения времени компиляции оптимально использовать формат Unix time~--- количество секунд, прошедших с момента времени 00:00:00 1 января 1970 года, обычно хранящееся в виде 4-х байтного знакового целого числа.
Такой формат является наилучшим, так как позволяет хранить время используя небольшой объём памяти, что является критичным, с учётом ограниченности объёмов EEPROM.

Логическая схема размещения данных в EEPROM показана на рисунке \ref{fig:logical-eeprom-data-structure}.

Для идентификации EEPROM-переменных было решено использовать произвольные строковые выражения~--- имена.
Причём хранение в энергонезависимой памяти имён целиком может привести к её большому расходу, если мена будет достаточно длинными.
Чтобы избежать этого, было приятно решение, хранить в памяти результат вычисления некоторой хеш-функции от имени переменной.
Такие значения всегда имеют фиксированную длину, в следствии чего объём используемой памяти будет всегда предсказуем.

\mysvg[inkscapelatex=false,width=\columnwidth]{logical-eeprom-data-structure}{логическая схема размещения данных в EEPROM}{fig:logical-eeprom-data-structure}


\subsection{Диаграмм классов библиотеки}

По итогам разработки структуры библиотеки была создана её диаграмма классов представленная на рисунке \ref{fig:class-diagram}.

\myfigure[width=0.7\columnwidth]{class-diagram}{Диграмма классов библиотеки}{fig:class-diagram}

\subsection{Внешний интерфейс библиотеки. Класс EEPROM-переменной}

Пользователю для использования должен быть доступен всего один класс EEPROMVar, описывающий EEPROM-переменную.
Данный класс является шаблонным, и его параметр типа определяет тип хранящихся пользовательских данных.

Этот класс имеет следующие методы
\begin{enumerate}
	\item Конструктор. Он принимает в качестве аргументов имя переменной и её значение по умолчание.
	Если переменная с таким именем уже существует, её значение считывается из энергонезависимой памяти и сохраняется в создаваемый объект, иначе в EEPROM создаётся новая переменная и в неё записывается значение по умолчанию.
	\item Update~--- запланировать запись нового значения в EEPROM.
	Метод имеет две перегрузки: не принимающую аргументов~--- для записи текущего значения пользовательских данных, и принимающая новое значение для этих данных, которая планирует запись этого нового значения.
	\item UpdateNow~--- метод для немедленного обновления значения в EEPROM.
	Так же имеет две перегрузки аналогично предыдущему методу.
	\item Data~--- метод, возвращающий по ссылке пользовательские данные, хранящиеся объектом.
	\item Оператор присваивания ("`="').
	Работает аналогично методу Update, принимая новое значение пользовательских данных в качестве правостороннего значения.
	В отличие от аналогичного оператора класса EEPROMVar библиотеки EEPROMEx, данный сам производит (отложенную) запись новых данных, без необходимости отдельного вызова метода записи.
	\item Оператор приведения объекта к типу хранящихся в нём пользовательских данных.
	Возвращает текущее значение хранимы данных, причём делает это по ссылке, как и метод Data.
\end{enumerate}

В виде полей данный класс хранит сами пользовательские данные и адрес в EEPROM для их обновления.

Можно привески следующий пример использования класса EEPROMVar:

\lstinputlisting[language=C++]{resources/code_listings/EEPROManager-var-example.cpp}

\begin{enumerate}
	\item Сначала пользователь объявляет EEPROM-переменную.
	Её значение либо считывается из EEPROM, либо наоборот сохраняется в него.
	\item Пользователь изменяет значение EEPROM-переменной. Значение в объекте изменяется немедленно, в энергонезависимой памяти~--- с помощью механизма отложенной записи.
	\item При необходимости, пользователь может в любой момент немедленно обновить значение в EEPROM.
	\item Пользователь может объявить EEPROM-переменную, хранящую более данные более сложных пользовательских типов (классов или структур).
	В примере~--- класс UserClass.
	\item Пользователь получает хранящееся значение сложного вызовом метода Data и затем вызывает у него некоторый метод, изменяющий значения его полей~--- UpdateField.
	В таком случае изменятся их значения изменятся только в оперативной памяти, так как, в отличие от пункта выше, оператор "`="' не вызывается.
	В таком случае для обновления значения в EEPROM пользователь может идти различными путями:
	\begin{itemize}
		\item Вручную вызвать метод Update или UpdateNow у объекта EEPROM-переменной.
		\item При возможности реализовать метод UpdateField таким образом, что бы он возвращал ссылку на изменённый объект.
		В таком случае можно его использовать как показано в троке 13 примера.
		\item Также существует вариант создания временный объект того же типа, что и данные, хранимые EEPROM-переменной, с последующими изменением этого объекта и записью в EEPROM уже этого, временного, объекта.
		Однако такой вариант проигрывает предыдущим и практически не имеет смысла.
	\end{itemize}
\end{enumerate}

\subsection{Класс менеджера EEPROM}

Данный класс (EEPROManager) предоставляет методы для поиска переменных в EEPROM по их именам, создания новых переменных и обновления хранимых ими значений.
EEPROManager не используется пользователем напрямую.
Его методы вызываются объектами класса описанного выше.

Во-первых данных класс содержит две встроенные структуры:

\begin{itemize}
	\item VariableInfo. Эта структура хранит метаинформацию о EEPROM-переменной в EEPROM: хеш-значение (CRC32) имени переменной, размер хранящихся пользовательских данных,адрес в EEPROM описания следующей переменной (при отсутствии следующей переменной равен нулю).
	Физически в энергонезависимой памяти всегда хранится такая структура, а начиная со следующего адреса сами пользовательские данные, описываемые структурой.

	\item MetaData~--- Общие мета-данные об EEPROM.
	Также сохраняет в энергонезависимой памяти и включает в себя описанные в пункте \ref{subsection:library-structure} специальное проверочное значение и временную метку времени компиляции загруженной в микроконтроллер программы.
\end{itemize}

К публичным методам класса относятся:
\begin{itemize}
	\item GetOrAddVar. Метод находит переменную в EEPROM по её имени или создает новую.
	\item Update~--- Планирует обновление данных в EEPROM.
	\item UpdateNow~--- Немедленно обновляет пользовательских данные.
\end{itemize}

Также в классе содержатся приватные методы:

\begin{itemize}
	\item init~--- Инициализирует менеджер. Читает мета-данные о сохраненных в EEPROM данных или записывает эту информацию, если это первый запуск.
	\item getVar~--- Получает адрес и данные переменной по её имени.
	\item addVar~--- Добавляет новую переменную в EEPROM и возвращает её адрес.
	\item readValue~--- Считывает данные пользовательских типов из EEPROM.
	\item getDataAddr~--- Получает адрес данных переменной по адресу её мета-информации.
	\item setVariablesExistence~--- Записывает в EEPROM информацию о добавлении первой переменной, если до этого переменных не существовало.
	\item getNewVarInfoAddr~--- Получает адрес для записи новой переменной.
\end{itemize}

И поля:

\begin{itemize}
	\item startAddr~--- Начальный адрес EEPROM для управления данными.
	\item lastVarInfoAddr~--- Адрес мета-данных последней записанной переменной.
	\item lastVarInfo~--- Сами такие мета-данные.
	Используются при добавлении новой переменной: в них обновляется адрес следующей переменной, так как теперь она существует.
	\item isInited~--- Значение, указывающее, был ли инициализирован менеджер.
\end{itemize}

\subsection{Хранение и поиск переменных в EEPROM}

В соответствии с описанием структуры VariableInfo, в EEPROM данный о каждой переменной хранятся в виде, представленном в таблице \ref{tab:eeprom-var}.

\begin{center}
	\begin{longtable}{|p{0.15\columnwidth}|p{0.15\columnwidth}|p{0.17\columnwidth}|p{0.45\columnwidth}|}
		\caption{ \raggedright Мета-данные EEPROM-переменной}
		\label{tab:eeprom-var}
		\\ \hline
		Размер данных & Сдвиг от начального адреса & Название поля & Описание \\
		\hline \endfirsthead
		\subcaption{\raggedright Продолжение таблицы~\ref{tab:eeprom-var}}
		\\ \hline \endhead
		\hline \subcaption{Продолжение на след. стр.}
		\endfoot
		\hline \endlastfoot
		4 байта & 0 байт & nameHash & Хэш-значение имени переменной. В данный момент используется хэш-функция CRC32 \cite{article:crc-32}. \\
		\hline
		2 байта & 4 байта & dataSize & Размер данных, хранящихся в переменной. \\
		\hline
		2 байта & 6 байт & nextVarAddr & Адрес следующей переменной. \\
		\hline
		Зависит от типа данных & 8 байт & data & Пользовательские данные, хранимые переменной. \\
	\end{longtable}
\end{center}


\subsection{Класс для чтения и записи данных}

Данный класс (EEPROMReaderWriter) является прослойкой между классом-менеджером и стандартной библиотекой для работы с EEPROM.
Он призван изолировать их конкретные реализации от менеджер, предоставляя ему унифицированный интерфейс из трёх методов:

\begin{itemize}
	\item ScheduleUpdate~--- Запланировать обновление данных произвольного типа по некоторому адресу.
	\item UpdateNow~---	Немедленное обновление данные произвольного типа в EEPROM.
	\item ReadValue~--- Чтение данных произвольного типа из EEPROM.
\end{itemize}

Каждый из таких методов переводит указатель на полученные данные произвольного типа в тип указателя на отдельный байт и в таком виде передаёт эти данные в соответствующий приватный метод.
Такие методы являются абстрактными и требую реализации для конкретных микроконтроллеров.
Список абстрактных методов:
\begin{itemize}
	\item scheduleUpdate~--- Запланировать обновление данных в EEPROM.
	\item updateNow~--- Немедленно обновить данные в EEPROM.
	\item readBytes~---	Чтение данных из EEPROM.
\end{itemize}

В рамках проведённой работы были разработаны реализации этого класса для целевых микроконтроллеров~--- платформы Arduino и ESP8266.


\section{Реализация библиотеки}

Библиотека была реализована в соответствии с представленной диаграммой.
В данном отчёте не приводятся детали реализации отдельных методов, однако исходный код разработанной библиотеки находится в открытом доступе в специальном репозитории, вместе с примерами использования и тестирующими библиотеку программами для микроконтроллеров \cite{web:eepromanager}.
Код также содержит комментарии-аннотации, необходимые для генерации документации средствами Doxygen \cite{web:doxygen}.

В приложении \ref{appendix:eeprom-usage-example} представлен пример минимальной программы для микроконтроллеров, использующей разработанную библиотеку.

Работа библиотеки была успешно протестирована на микроконтроллерах серии ESP8266 и платформы Arduino.
Средства библиотеки корректно решают все поставленные перед ней задачи.
