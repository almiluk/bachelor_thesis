\chapter{Разработка библиотеки для сетевой самоидентификации периферийных устройств}

\section{Требования к модулю}
	
\subsection{Общие требования}

Все требования в этом подпункте основаны на документации к протоколу SSDP[15].
В большинстве случаев (в том числе в условиях решаемой задачи) существует чёткое разделение устройств на производящие поиск и искомые, для встраиваемых устройств достаточно реализовать часть протокола, описывающую поведение искомого устройства.
А именно:
\begin{itemize}
	\item Отправка пакетов-уведомлений, о вхождении устройства и его сервисов в сеть.
	\item Приём и обработку пакетов, передающих поисковые запросы.
	\item Ответ на поисковой запрос, в случае если устройство соответствует условию поиска.
	\item Отправка пакетов-уведомлений перед выходом устройства из сети.
\end{itemize}
Подробное описание структуры указанных пакетов, а также требований к их обработке и отправке приведено в пункте 6 данной главы.

Помимо этого примем ещё одно допущение.
Согласно стандарту SSDP, устройство может иметь в своём составе ещё несколько встроенных устройств, которые, в свою очередь, могут предоставлять свои отдельные сервисы.
Однако, выполнение данного модуля предполагается на устройствах Интернета вещей, которые, в большинстве случаев, имеют достаточно простую структуру и не несут в себе отдельных встроенных устройств.
Поэтому для данного модуля является допустимой поддержка только головного устройства, которое само предоставляет некоторые сервисы, но не имеет других встроенных устройств.

Разрабатываемый программный модуль должен позволять настроить и в будущем считать все атрибуты устройства, которыми оно должно обладать в соответствии со стандартом SSDP, а именно:
\begin{enumerate}
	\item Тип устройства в установленном стандартом формате.
	\item Перечень сервисов, предоставляемых устройством.
	Он может быть пустым.
	\item Уникальный идентификатор устройства в специальном формате.
	\item Ссылка на веб-страницу, содержащую описание устройства в установленном формате.
	\item Его человекочитаемое имя.
	\item Ссылку на страницу веб-страницу, как-либо презентующую данное устройство.
	\item Название его модели.
	\item Номер модели.
	\item Серийный номер устройства.
	\item Название его производителя.
	\item Ссылка на веб-страницу, описывающую производителя.
	\item Номер HTTP порта устройства, обратившись по которому можно получить веб-страницу, описанную в пункте 4 данного списка.
\end{enumerate}

Для поиска устройства необходимыми являются только атрибуты под номерами 1--3, поэтому, если их значения не будут заданы пользователем, они должны быть проинициализированы значениями по умолчанию.
Остальные атрибуты используются для формирования описания устройства на веб-странице из пункта 4 списка выше.
Они не учувствуют в процессе поиска и могут иметь нулевые (пустые) значения.

\subsection{Требования платформы SciVi}

Аналогично библиотеке менеджера EEPROM, разрабатываемый модуль должен быть представлен библиотекой классов языка C++, использовать стандартный набор библиотек Ardiono IDE и работать на микроконтроллерах ESP8266.
ESP8266 имеет в своём составе встроенный блок для подключения к сетям Wifi, а набор стандартных библиотек для этих устройств включают достаточно высокоуровневые готовые средства для управления блоков WiFi и сетевого взаимодействия с другими устройствами. 
В том числе для приёма и отправки UDP пакетов на мультивещательные адреса.
Устройства платформы по Ardiono не имеют встроенной возможности для сетевой коммуникации.
Обычно для этого к ним подключаются другие устройства, например, EPS8266.
В следствии этого, разрабатываем модуль не обязан выполнятся на других микроконтроллерах и может использовать возможности и средства специфичные только для ESP8266.

По протоколу SSDP данные передаются в виде текста в формате HTTP заголовков, поэтому для передачи онтологий программный модуль должен содержать механизм добавления к отправляемым пакетам дополнительных заголовков.
Кроме того, пользователю должна быть предоставлена возможность настройки состава добавляемых заголовков, в зависимости от атрибутов отправляемого пакета: от его типа (уведомление или ответ на поисковой запрос) и типа устройства или сервиса, информацию о котором он передаёт.

После сжатия, объём передаваемых платформой SciVi антологии обычно не превышает нескольких сотен байт, а UDP-пакеты, которые используются протоколом SSDP для передачи данных, имеют ограничение на размер в 65,535 байт.
Таким образом, одного UDP пакета должно быть достаточно для передачи устройством всех необходимых данных, включая онтологию.
Однако сохраняется теоретическая возможность выхода за пределы указанного ограничения, и подобные ситуации необходимо специально отслеживать.

\section{Анализ существующих реализаций протокола}

На момент выполнения работы для ESP8266 уже существовала реализация протокола SSDP в виде библиотеки для языка C++ \cite{bib:library}.
Однако она реализует устаревшую версию протокола, причём не полностью и с нарушениями стандарта.
Данная библиотека предоставляет возможность поиска только по типу устройства и его идентификатору, не имея возможности работать с отдельными сервисами.
Также она некорректно обрабатывает ряд редких, но возможных ситуаций, связанных с получением нескольких поисковых запросов за малый промежуток времени, и нарушает требования стандарта SSDP по отправке пакетов-уведомления о входе устройства в сеть и выходе из неё.
Помимо этого, данная библиотека не предоставляет удобной возможности для настройки атрибутов устройства, требуя от пользователя самостоятельно приводить их к форматам, соответствующим стандарту SSDP.

Также стоит отметить, что структура описанного выше класса не позволяет в значительном объёме переиспользовать его с помощью наследования или вызова существующих методов, однако позволяет переиспользовать отдельные фрагменты самого кода (что не противоречит лицензии, под которой данная библиотека распространяется~--- MIT).

\section{Разработка структуры библиотеки}

С учётом стиля большинства подобных библиотек, общих современных тенденций, а также уже существующей реализации, оптимальным вариантом является создание модуля в объектно-ориентированном стиле.
Разрабатываемая библиотека должна решать одну конкретную задачу, и в ней нет необходимости создавать новых типы данных, реализация которых уже не присутствовала бы в стандартных библиотеках.
Поэтому всю функциональность библиотеки можно поместить в один класс.

Причём имеет смысл сохранить обратную совместимость этого класса с соответствующим классом существующей библиотеки, с целью создания возможности лёгкого перехода с неё на более полную реализацию в уже созданных проектах.
Этот класс должен содержать следующие публичные методы:

\begin{enumerate}
	\item Методы для установки и получения значений каждого из атрибутов устройства, описанных в пункте 2.2.1, а также настроек самой библиотеки: времени жизни, отправляемых ей пакетов (англ. Time To Live, TTL), временного интервала повтора уведомлений (см пункт 2.5).
	\item Метод для инициализации класса, запуска его работы.
	Данный метод стоит реализовать отдельно, а не в виде конструктора, т.к. при программировании микроконтроллеров часто используются глобальные переменные (причём именно в виде значений, а не указателей на них), которые затем в специальной функции инициализируются в необходимом программисту порядке.
	\item Метод завершения работы объекта и очистки его ресурсов.
	Использование только деструктора для этих целей также будет неправильным из-за частого использования глобальных переменных.
\end{enumerate}

С учётом использования ООП подхода, механизм расширения функциональности модуля, указанный в требованиях к нему, можно удобно для использования реализовать с использованием наследования.
Для этого необходимо определить доступные для переопределения в классах-потомках методы, которые бы вызывались автоматически перед отправкой SSDP пакетов (по одному такому методу на каждый тип SSDP пакетов) для возможности добавления в пакет новых заголовков из этих методов.
Кроме того, необходим сам метод добавления нового заголовка в текущий отправляемый пакет.
А для большей гибкости ещё и метод, возвращающий значение, которое бы показывало информацию о чём содержит текущий отправляемый пакет (о типе устройства, сервисе и т.д), для возможности выбора различных действий в зависимости от этого значения.

Главным приватным методом является метод обработки получаемых пакетов.
Этот метод должен вызываться с определённой периодичностью, и если между его вызовами был получен UDP пакет, проанализировать его и в зависимости от результата анализа отправить ответ или не делать ничего.
Также необходимо создать несколько вспомогательных методов: метод, реализующий отправление пакетов другим устройствам, метод, генерирующий значения заголовков для ответов и т.д.

Для периодического вызова метода, описанного выше, существуют 2 очевидных механизма:

\begin{itemize}
	\item Первый~--- использующий программный таймер, который раз в заданный промежуток времени вызывал бы этот метод.
	Класс, предоставляющий возможности такого таймера, содержится в одной из библиотек стандартного набора.
	Использование такого механизма не требует никаких действий после инициализации объекта и позволяет упростить написание кода, использующего разрабатываемую библиотеку, однако использование таймера может мешать выполнению других частей прошивки.
	К тому же, оно не соответствует наиболее распространённому среди разработчиков программ для подобных микроконтроллеров стилю вызова подобных методов.
	\item Альтернативный механизм является более простым и привычным большинству программистов микроконтроллеров.
Он заключается в ручном вызове этого метода в специальной функции, циклически повторяющейся в течение всего времени работы устройства.
\end{itemize}

С целью придания библиотеке большей гибкости предлагается реализовать оба этих механизма, а также дополнительный публичный метод, переключающий объект между этими механизмами.

\section{Разработка библиотеки}

\subsection{Хранение данных}
Большая часть данных, хранящихся в объекте разрабатываемого класса, являются текстовыми атрибутами устройства.
И, так как стандарт SSDP накладывает жёсткие ограничения на длину каждого из этих атрибутов, имеет смысл отказаться от динамических строк, а хранить и обрабатывать значения этих атрибутов в виде массива символов.
Такое решение обезопасит память от возможного переполнения и увеличит скорость обработки текстовых значений.

Название типов устройств и сервисов должны описываться комбинацией трёх строковых значений: домена имён, самого имени типа и версии, однако, в дальнейшей обработке участвует только комбинация этих значений, и никогда каждое отдельно.
Поэтому есть смысл один раз, при получении этих 3 значений для каждого из имён устройства и сервисов, составить из них итоговую комбинацию и далее хранить именно эту комбинацию в виде единого текстового значения в необходимом формате.
Описание данных форматов приведено ниже согласно документации к протоколу SSDP.

\subsubsection{Формирование пакетов}

Любой SSDP пакет содержит:
\begin{itemize}
	\item Стартовую строку, описывающую сам пакет.
	\item Обязательные заголовки с фиксированными значениями.
	\item Обязательные заголовки с значениями, зависящими от имён устройства и его сервисов.
	\item Ноль или более необязательных заголовков.
\end{itemize}

Как упоминалось ранее, все SSDP пакеты делятся на:
\begin{enumerate}
	\item Пакеты-уведомления о вхождении в сеть
	\item Пакеты-уведомления о выходе из сети
	\item Поисковые пакеты
	\item Пакеты-ответы на поисковые запросы
\end{enumerate}

Структура пакетов разных видов может отличаться.
Рассмотрим пакеты-уведомления, их структура представлена на рисунке \ref{fig:notification-packet}.

\myfigure[width=\columnwidth]{notification-packet}{Состав пакета-уведомления}{fig:notification-packet}

Стартовая строка таких пакетов всегда имеет вид "`NOTIFY * HTTP/1.1"'.
Затем идут обязательные заголовки: 
\begin{itemize} 
	\item Заголовок HOST, значение которого всегда 239.255.255.250:1900, т.к.
	IP-адрес 239.255.255.250, представляющий мультивещательную группу, и порт номер 1900 закреплены за данным протоколом.
	\item Заголовок CACHE-CONTROL со значением "`max-age ="' и целым числом, указывающим, в течении какого времени без повторного уведомления устройство или сервис можно считать оставшимися в сети.
	\item Заголовок LOCATION, хранящий значение веб-адреса страницы с описанием устройства.
	\item Заголовок NT, он описывает тип устройства или сервиса, о котором оповещает данный пакет.
	Данный заголовок может принимать различные значения, их формат представлен на рисунке \ref{fig:nt-usn-headers}.
	\item Заголовок NTS определяет тип сообщения, его значение равно "`ssdp:alive"' для уведомлений первого типа и "`ssdp:byebye"' для второго.
	\item Заголовок SERVER описывает систему, с которой пакет был отправлен, для разрабатываемой библиотеки его значение формируется в формате "`Arduino/1.0 UPNP/2.0 <название модели устройства>/<номер модели устройства>"' (см. рисунок \ref{fig:nt-usn-headers}).
	\item Заголовок USN является комбинацией уникального идентификатора устройства в формате "`uuid:<значение идентификатора>"' и значения заголовка NT, записанных через два символа двоеточия.
	\item Заголовок CONFIGID.UPNP.ORG~--- некоторое положительное 31-битное число, изменяющееся каждый раз, когда меняется состав устройства и его сервисов, либо версия одного из них.
	Отслеживание подобных изменений является неоправданно сложной в рамках разработки данной библиотеки, поэтому по умолчанию значение этого заголовка будет оставаться нулевым, однако, класс предоставляет возможность пользователю самому вычислять это значение и устанавливать с помощью соответствующего метода.
	\item Заголовок BOOTID.UPNP.ORG~--- аналогичное предыдущему значение, но которое должно изменяться при каждом подключении устройства в сети.
	Данное значение также не обрабатывается библиотекой автоматически.
\end{itemize}

\myfigure[width=\columnwidth]{nt-usn-headers}{Возможные значения заголовков NT и USN (подчёркнутый текст~--- ключевые слова, курсивный~--- значения, задаваемые производителем)}{fig:nt-usn-headers}

Согласно стандарту SSDP, устройство должно отправить ssdp:alive уведомление о головном устройстве и о каждом предоставляемом им сервисе при входе в сеть и аналогично ssdp:byebye уведомления при выходе из неё.

Стартовая строка поисковых запросов отличается только HTTP методом: "`M-SEARCH"' вместо "`NOTIFY"', а наборы заголовков в таком пакете могут быть очень разнообразными, минимальный состав такого пакета приведён на рисунке \ref{fig:min-search-packet}.
Важными для поиска в них являются только:

\begin{itemize}
	\item MAN, значение которого должно быть "`ssdp:discover"'
	\item MX~--- целое число секунд, в течении которого после получения этого пакета, в случайный момент времени устройство должно послать ответ, в случае, если оно удовлетворяет условию поиска.
	\item ST~--- цель (условие) поиска, значение формируется аналогично значению заголовка NT пакета-уведомления, либо может являться специальным значением "`ssdp:all"'.
\end{itemize}

Если значение заголовка ST совпадает со значением заголовка NT устройства или его сервиса, устройство обязано послать ответный пакет.

\myfigure[width=\columnwidth]{min-search-packet}{Состав минимального поискового пакета}{fig:min-search-packet}

Стартовая строка пакета, являющегося ответом на поисковый запрос, строится по принципу такой строки в HTTP ответе, и её значение равно "`HTTP/1.1 200 OK"'.
Такой пакет должен содержать следующие заголовки:
\begin{itemize}
	\item CACHE-CONTROL, LOCATION, SERVER, BOOTID.UPNP.ORG, CONFIGID.UPNP.ORG со значениями, аналогичными пакетам-уведомлениям.
	\item ST, значение которого совпадает со значением одноимённого заголовка в поисковом пакете, на который производится ответ.
	\item USN, со значением, аналогичным значению этого заголовка в пакете-уведомлении.
	\item EXT с пустым значением.
Этот заголовок необходим для обратной совместимости со старой версией протокола.
\end{itemize}

\subsection{Анализ получаемых пакетов}

Для синтаксического разбора получаемых поисковых пакетов был использован автомат состояний.
На диаграмме его состояний (Рисунок \ref{fig:packet-parse-state-diagram}) состояние "`Обработка ошибки в пакете"' означает, что поступивший пакет некорректен или его цель поиска не удовлетворяется данным устройством, поэтому данный пакет необходимо проигнорировать.
Названия других состояний совпадают с названиями обрабатываемых в этот момент лексем пакета.

\myfigure[width=\columnwidth]{packet-parse-state-diagram}{Диаграмма состояний синтаксического анализатора SSDP пакетов}{packet-parse-state-diagram}

\subsection{Итоговая диаграмма состояний объекта}

В соответствии с документацией протокола SSDP, цикл работы объекта, реализующего этот протокол, можно описать в виде диаграммы состояний.
Она представлена на рисунке \ref{fig:state-diagram}.
Желтым цветом на диаграмме обозначена функциональность, которую необходимо реализовать пользователю библиотеки с помощью механизмов, описанных в пункте 2.4.

\myfigure[width=\columnwidth]{state-diagram}{Диаграмма состояний объекта}{state-diagram}

\subsection{Разработка средств тестирования}

Для тестирования разрабатываемого модуля были созданы специальная прошивка для микроконтроллера и программа на языке Python, выполнение которой предполагается на другом устройстве.
Данная программа в процессе тестирования принимает все SSDP пакеты, отправляемые микроконтроллером, и проверяет их корректность и своевременность.
А прошивка микроконтроллера, в свою очередь, задействует все основные возможности библиотеки по отправке и обработке пакетов, то есть отправку мультивещательных пакетов-уведомлений о вхождении в сеть и выходе из неё, ответы на поисковые запросы, которым устройство удовлетворяет, игнорирование остальных, а также механизм расширения отправляемых пакетов дополнительными заголовками.

\subsection{Тестирование}

Для тестирования разработанной библиотеки на компьютере, находящемся в одной сети с микроконтроллером, была запущена программа, описанная в предыдущем пункте.
На самом микроконтроллере была загружена прошивка из того же пункта.
В ходе тестирования библиотека отработала корректно, отправив все необходимые пакеты и добавив к верной их части дополнительные заголовки.
Результат тестирующей программы представлен на рисунке \ref{fig:test-results}.

\myfigure[width=\columnwidth]{test-results}{Диаграмма состояний объекта}{fig:test-results}


\section{Возможности для интеграции разработанного модуля в платформу SciVi}

\subsection{Основные идеи интеграции}

Разработанный модуль позволяет осуществлять поиск устройств по их типу и типам сервисов, которые они предоставляют.
Протокол SSDP не накладывает ограничений на типы сервисов, поэтому можно использовать различные операторы SciVi в качестве сервисов, предоставляемых устройствами.
Например, устройство может предоставлять функции арифметических вычислений, измерения расстояния или быть аналогово-цифровым преобразователем (АЦП).

В случае необходимости выполнения оператора, серверная часть платформы SciVi должна отправить поисковый SSDP запрос, целью которого будет являться SSDP сервис, соответствующий этому оператору.
Кроме того, устройствам можно присваивать человекочитаемые имена, что позволит удобно выбирать необходимое устройство из найденных на интерфейсе платформы.

Также в рамках развития платформы SciVi разрабатывается протокол для самоидентификации сенсоров и актуаторов, подключенных к устройствам IoT.
Это достигается добавлением к каждому из них маломощного микроконтроллера с прошивкой, реализующей этот протокол.
Головной микроконтроллер сможет автоматически определять механизмы работы с подключенными устройствами.
Каждый сенсор и актуатор также будет советовать оператору SciVi, формируя описание своего состава в виде онтологий.
Затем будет создаваться полное онтологическое описание составного устройства на основе этих данных.

С учетом этих возможностей, поиск устройств можно проводить по их типам, а конкретные возможности каждого устройства передавать в дополнительном заголовке ответа на поисковый запрос в виде сжатой онтологии.

\subsection{Интеграция в прошивку встраиваемых устройств}

Для успешной интеграции разработанного модуля в платформу SciVi необходима возможность подключения нескольких микроконтроллеров к единой существующей Wi-Fi сети.
Однако на момент выполнения работы такая возможность отсутствовала в прошивках, используемых в SciVi.
Для решения этой проблемы был создан дополнительный программный модуль для микроконтроллеров на основе существующего кода.

Этот модуль предоставляет пользователю веб-интерфейс для подключения к Wi-Fi сети (см.
Рисунок \ref{wifi-interface}) и позволяет хранить данные для подключения в энергонезависимой памяти, чтобы обеспечить долговременную настройку соединения.
Структура класса, реализующего возможность подключения к сети Wi-Fi, представлена на рисунке \ref{fig:wifi-conn-cd}.

\myfigure[width=\columnwidth]{wifi-interface}{Внешний вид интерфейса подключения устройства IoT к сети Wi-Fi}{fig:wifi-interface}

\myfigure[width=\columnwidth]{wifi-conn-cd}{Структура класса, реализующего возможность подключения к сети Wi-Fi}{fig:wifi-conn-cd}

После успешного подключения устройства к сети необходимо настроить модуль SSDP.
Для первого сценария, описанного в предыдущем разделе, требуется вызов специального метода, где указывается список сервисов, предоставляемых устройством, каждый из которых описывает некоторый оператор SciVi.
Для второго сценария необходимо расширить функциональность класса, реализующего SSDP, чтобы при ответе на определенные поисковые запросы отправлялась сжатая онтология, описывающая состав устройства.
Механизм такого расширения описан в главе 2.

\subsection{Интеграция в серверную часть}

Серверная часть платформы SciVi реализована на языке программирования Python с использованием фреймворка Flask.
Для добавления возможности поиска устройств к серверу необходимо реализовать функцию поиска на языке Python или на любом другом языке, который может быть использован из Python.
Эта функция должна принимать следующие аргументы:

\begin{itemize}
	\item Название домена типов, к которому принадлежит искомый тип устройства или сервиса, название самого типа и его версию.
	\item Уникальный идентификатор устройства или сервиса.
	\item Специальное имя цели поиска, например, "`ssdp::all"'.
\end{itemize}

Затем, в зависимости от переданных аргументов, функция должна сформировать поисковый запрос с соответствующей целью, создать SSDP пакет, выполнить поиск устройств и вернуть адреса найденных устройств в сети и заголовки, содержащиеся в их ответах на поисковый запрос для дальнейшей обработки.
Упрощенная версия такой функции уже была реализована в рамках данной работы, и ее исходный код приведен в приложении \ref{app:appendix-search-func}.
