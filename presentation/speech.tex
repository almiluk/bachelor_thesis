\documentclass[14pt]{extarticle}
\usepackage{cmap}
\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage[english, russian]{babel}

\usepackage{geometry}
\geometry{
	a4paper,	% size of paper
	left=10mm,	%
	right=15mm,	% margins
	top=10mm,	%
	bottom=10mm,%
}

\usepackage{setspace}
\singlespacing % line spacing

\usepackage{ragged2e}
\hyphenchar\font=-1
\sloppy

\begin{document}

\begin{enumerate}
	\item \textbf{}
	\item \textbf{Интернет вещей}

	Концепция Интернета вещей в сегодняшние дни активно развивается и находит своё применения в огромном множестве сфер личного и промышленного использования.
	При этом, программирование устройств Интернета вещей всё ещё остаётся достаточно трудоёмким процессом и требует значительной квалификации разработчика, что затрудняет использование IoT для решения прикладных задач специалистами в их предметных областях.
	\item \textbf{ODEC}

	Одним из подходов, решающих данную проблему являются онтологически управляемые периферийные вычисления.
	Данный подход предлагает заменить использование классических прошивок (встраиваемых программы) периферийных устройств на комбинацию из:
	\begin{itemize}
		\item Доменной онтологии, описывающей общие знания.
		\item Онтологии задачи, описывающей действия, необходимые для решения конкретной задачи.
		\item Механизма логического вывода, запускаемого на периферийных устройствах и выполняющего эти действия.
	\end{itemize}
	Такой подход обладает массой преимуществ, и, в конечном счёте, позволяет добиться автоматизации процесса программирования устройств и снижения минимального необходимый уровень квалификации разработчика.
	\item \textbf{SciVi}

	Данный подход используется платформой научной визуализации и визуальной аналитики SciVi.
	Платформа SciVi позволяет описывать алгоритмы сбора, обработки и отображения данных, и выполнять эти алгоритмы, при этом храня и передавая их в виде онтологий.
	\item \textbf{Редактор SciVi}

	Причём описание алгоритмов происходит декларативно, с помощью графического редактора, в котором пользователь может легко описать необходимые действия в виде диаграмм потоков данных.
	Часть из этих действий как раз и может быть выполнена на устройствах Интернета вещей.
	Использование онтологически управляемых периферийных вычислений помогает платформе автоматизировать процесс их программирования.
	\textbf{Однако, уровень автоматизации программирования этих устройств остаётся недостаточным, в следствии того, что часть связанных с этим задач остаётся нерешённой в рамках платформы SciVi.}
	Решению этих и посвящена данная работа.
	\item \textbf{Объект и предмет}

	Таким образом:
	\textbf{Объект исследования}: автоматизация периферийных вычислений.
	\textbf{Предмет исследований}: средства платформы SciVi для организации онтологически управляемых периферийных вычислений.
	\item \textbf{Цель ВКР}:

	Создание комплексного решения по  автоматизации программирования устройств Интернета вещей на базе платформы SciVi путём реализации недостающей функциональности в рамках концепции онтологически управляемых периферийных вычислений
	\item \textbf{Недостающая функциональность}

	К упомянутым в постановке цели возможностям, которых недостаёт платформе для достижения желаемого уровня автоматизации:
	\begin{itemize}
		\item \textbf{Автоматическое обнаружения периферийных устройств в локальной сети}
		\item \textbf{Возможности эффективного взаимодействия с энергонезависимой памятью периферийных устройств}
	\end{itemize}
	Два этих пункта и являются необходимо функциональность, в реализации которой заключалась данная работы.
	\item \textbf{Задачи}

	\item \textbf{ESP8266}

	Основным устройством IoT, используемым платформой SciVi являются микроконтроллеры ESP8266.
	В следствии этого, именно они являются целевой аппаратной платформой для всей последующей работы.
	Для программирования ESP8266 используется язык программирования C++ и средства среды разработки Arduino IDE.
	\item \textbf{Менеджер EEPROM}

	Первой практической задачей данной работы стала разработка библиотеки управления энергонезависимой памятью устройств Интернета вещей.
	В качестве такой памяти в целевых устройствах используется EEPROM, т.е. электрически стираемое перепрограммируемое постоянное запоминающее устройство.

	\item \textbf{Требования}
	Перед такой библиотекой были поставлены требования:
	\begin{enumerate}
		\item Наличие возможности сохранять и считывать данные произвольной структуры из EEPROM
		\item Высокоуровневый интерфейс
		\item Обращение к хранимым данным по именам, а не физическим адресам
	\end{enumerate}

	В качестве второстепенного требования библиотека должна минимизировать количества операций записи, т.к. оно ограничено для EEPROM каждого устройства.

	\item \textbf{Существующие решения}

	Были изучены существующие решения для управления EEPROM, которые обладают общими недостатками в виде:
	\begin{enumerate}
		\item Отсутствие возможности именования данных
		\item Отсутствие механизмов оптимизации под целевые устройства. Они необходимы, так как в EEPROM ESP8266 обладает рядом рядом особенностей
		\item Ряд из них также позволяют хранить данные только базовых тип, но не создаваемых пользователем.
	\end{enumerate}

	В конечном счёте эти недостатки делают невозможным выполнение поставленных платформой требований с помощью существующих средств.

	\item \textbf{Диаграмма классов}

	В следствии этого была спроектирована собственная библиотека, диаграмма классов которой представлена на слайде.
	На этой диаграмме мне хотелось бы обратить ваше внимание на два участка.

	\item \textbf{Класс чтения/записи}

	Первый из них - класс, предоставляющий низкоуровневые возможности для чтения и записи произвольных данных по конкретным адресам.
	Стандартные библиотеки для работы с EEPROM различных устройств предоставляют различные интерфейсы, в следствии чего часть методов данного класса является абстрактной и может быть реализована для различных устройств.

	\item \textbf{Реализации класса чтения/записи}

	В рамках работы были разработаны две их реализации: для микроконтроллеров ESP8266 и ATmega как для наиболее популярной платформы в целом.

	\item \textbf{Конструктор. Автоматическая адресация}

	Также важно обратить внимание на интерфейс, который предоставляет библиотека.
	Показанный на слайде класс позволяет описать один блок пользовательских данных в EEPROM.
	Как можно увидеть, его конструктор, в состоянии с требованиями, позволяет обращаться к данным по именам, а не физическим адресам.
	Уточню, что второй параметр конструктора - значение по умолчанию, а не адрес, как могло бы показаться.

	\item \textbf{Переопределения операторов для приведения типов}

	Также для данного класса переопределён ряд операторов, реализующих приведение типов от данного класса к типу хранимых им данных и обратно.
	Что позволяет пользователю оперировать объектом этого класса, как самими данными, хранимыми в нём.

	\item \textbf{Преимущества разработанной библиотеки}

	Помимо озвученного, разработанная библиотека реализует механизм уменьшения износа EEPROM специально с учётом особенностей целевых устройств.

	\textbf{Таким образом, разработанная библиотека полностью удовлетворяет поставленным требованиям для использования в рамках платформы SciVi.}

	\item \textbf{Средство автоматизации обнаружения периферийных устройств в локальной сети}

	\item \textbf{Анализ протоколов самоидентификации}

	\item \textbf{SSDP}

	\item \textbf{Диаграмма состояний синтаксического анализатора}

	\item \textbf{Диаграмма рабочего цикла. Анализ полученного запроса}

	\item \textbf{Диаграмма рабочего цикла. Добавление необязательных заголовков}

	\item \textbf{Расширение протокола. Фрагмент диаграммы классов}

	\item \textbf{Достигнутые результаты}

	\item \textbf{Список слайдов}
\end{enumerate}

\end{document}
